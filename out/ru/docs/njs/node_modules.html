<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Использование модулей Node.js в njs</title><style type="text/css">body { background: white; color: black; font-family: sans-serif; line-height: 1.4em; text-align: center; margin: 0; padding: 0; } #banner { background: black; color: #F2F2F2; line-height: 1.2em; padding: .3em 0; box-shadow: 0 5px 10px black; } #banner a { color: #00B140; } #main { text-align: left; margin: 0 auto; min-width: 32em; max-width: 64em; } #menu { float: right; width: 11em; padding: 0 .5em 1em .5em; border-left: 2px solid #DDD; } #content { margin-right: 13.5em; padding: 0 .2em 0 1.5em; } h1 { display: block; font-size: 3em; text-align: left; height: .7em; margin: 0; margin-bottom: .5em; } h1 img { width: 100%; } h2 { text-align: center; } p { text-align: justify; } table.news p { margin-top: 0; } table.news td { vertical-align: baseline; } table.news .date { text-align: right; padding-right: 0.5em; white-space: nowrap; } table.donors td { vertical-align: baseline; } table.donors li { text-align: left; } div.directive { background: #F2F2F2; line-height: 1em; margin: 1em 0 1em -1em; padding: .7em .7em .7em 1em; border-top: 2px solid #DDD; } div.directive th { padding-left: 0; padding-right: .5em; vertical-align: baseline; text-align: left; font-weight: normal; } div.directive td { vertical-align: baseline; } div.directive pre { padding: 0; margin: 0; } div.directive p { margin: .5em 0 0 .1em; font-size: .8em; } a.notrans { color: gray; text-decoration:none; } span.initial { font-size: 200%; float: left; padding-right: 10pt;} ul, ol { margin: .5em 0 1em 1em; padding: 0 .5em; } ol { list-style-position: inside; } li { text-align: justify; padding: .5em 0 0 1px; } .compact li { padding-top: 0; } dl { margin: .5em 0 1em 0; } dt { margin: .5em 0; } .compact dt { margin-bottom: .2em; } dd { margin-left: 1.5em; padding-left: 1px; text-align: justify; } td.list { background: #F2F2F2; } blockquote { margin: 1em 0 1em 1em; padding: .5em; } li blockquote, dd blockquote { margin: .7em 0; } blockquote.note { border: 1px dotted #999; line-height: 1.2em; text-align: justify; } blockquote.example { line-height: 1em; border-left: 1px solid #BBB; } blockquote.example pre { padding: 0; margin: 0; } sup { font-size: 50%; } .video { position: relative; padding-bottom: 56.25%; overflow: hidden; } .video iframe, .video object, .video embed { position: absolute; top:0; left:0; width:100%; height:100%; }</style><script>
        window.addEventListener("load", function(e) {
            fetch("../../../banner/banner.html")
                .then((response) => response.text())
                .then((resp) => {
                    document.getElementById("banner").innerHTML = resp;
                })
                .catch((error) => {
                    console.warn(error);
                });
        });
    </script></head><body><div id="banner"></div><div id="main"><div id="menu"><h1><a href="/"><img src="/nginx.png" alt="nginx"></a></h1><div>english<br><a href="../../../ru/">русский</a><br><br><a href="../../../">news</a><br><a href="../../../en/">about</a><br><a href="../../../en/download.html">download</a><br><a href="../../../en/security_advisories.html">security</a><br><a href="../../../en/docs/">documentation</a><br><a href="../../../en/docs/faq.html">faq</a><br><a href="../../../en/books.html">books</a><br><a href="../../../en/support.html">support</a><br><br><a href="http://trac.nginx.org/nginx">trac</a><br><a href="http://twitter.com/nginxorg">twitter</a><br><a href="https://www.nginx.com/blog/">blog</a><br><br><a href="https://unit.nginx.org/">unit</a><br><a href="../../../en/docs/njs/">njs</a><br></div></div><div id="content"><h2>Использование модулей Node.js в njs</h2><table width="100%"><tr><td align="left"><a href="#environment">Окружение</a><br><a href="#protobuf">Protobufjs</a><br><a href="#dnspacket">Пакет DNS</a><br></td></tr></table><a name="intro"></a><p>
Часто разработчику приходится использовать сторонний код и,
как правило, такой код доступен в виде библиотеки.
В JavaScript концепция модулей является новой и
до недавнего времени не была стандартизированa.
До сих пор множество платформ или браузеров не поддерживают модули,
по этой причине практически невозможно повторно использовать код.
В данной статье приводятся способы повторного использования
кода в njs при помощи <a href="https://nodejs.org/">Node.js</a>.
</p><blockquote class="note">
В примерах статьи используется функциональность
<a href="index.html">njs</a>
<a href="changes.html#njs0.3.8">0.3.8</a>
</blockquote><p>
При добавлении стороннего кода в njs
может возникнуть несколько проблем:

</p> <ul class="compact">

<li>
большое количество файлов, ссылающихся друг на друга, и их зависимости
</li>

<li>
платформозависимые API
</li>

<li>
языковые конструкции нового стандарта
</li>

</ul><p> 
</p><p>
Однако это не является чем-то новым или специфичным для njs.
Разработчикам JavaScript приходится часто иметь дело с подобными случаями,
например при поддержке нескольких несхожих платформ
с разными свойствами.
Данные проблемы можно разрешить при помощи следующих инструментов:

</p> <ul class="compact">

<li>
Большое количество файлов, ссылающихся друг на друга, и их зависимости
<p>
Решение: слияние всего независимого кода в один файл.
Для этих целей могут использоваться утилиты
<a href="http://browserify.org/">browserify</a> или
<a href="https://webpack.js.org/">webpack</a>,
позволяющие преобразовать проект в один файл, содержащий
код и все зависимости.
</p>
</li>

<li>
Платформозависимые API
<p>
Решение: использование библиотек, реализующих подобные API
в платформонезависимом режиме, однако в ущерб производительности.
Определённая функциональность может быть также реализована при помощи
<a href="https://polyfill.io/v3/">polyfill</a>.
</p>
</li>

<li>
Языковые конструкции нового стандарта
<p>
Решение: трансплирование кода — 
ряд преобразований,
заменяющих новые функции языка в соответствии со старым стандартом.
Для этих целей может использоваться
<a href="https://babeljs.io/"> babel</a>.
</p>
</li>

</ul><p> 
</p><p>
В статье также используются две относительно большие
библиотеки на основе npm:

</p> <ul class="compact">

<li>
<a href="https://www.npmjs.com/package/protobufjs">protobufjs</a> — 
библиотека для создания и парсинга protobuf-сообщений, используемая
протоколом <a href="https://grpc.io/">gRPC</a>
</li>

<li>
<a href="https://www.npmjs.com/package/dns-packet">dns-packet</a> — 
библиотека для обработки пакетов протокола DNS
</li>

</ul><p> 
</p><a name="environment"></a><center><h4>Окружение</h4></center><p>
</p> <blockquote class="note">
В статье описываются общие принципы работы
и не ставится цель описания подробных сценариев работы с Node.js
и JavaScript.
Перед выполнением команд
необходимо ознакомиться с документацией соответствующих пакетов.
</blockquote><p> 
Сначала, предварительно установив и запустив Node.js, необходимо создать
пустой проект и установить зависимости;
для выполнения нижеперечисленных команд необходимо
находиться в рабочем каталоге:
</p> <blockquote class="example"><pre>
$ mkdir my_project &amp;&amp; cd my_project
$ npx license choose_your_license_here &gt; LICENSE
$ npx gitignore node

$ cat &gt; package.json &lt;&lt;EOF
{
  "name":        "foobar",
  "version":     "0.0.1",
  "description": "",
  "main":        "index.js",
  "keywords":    [],
  "author":      "somename &lt;some.email@example.com&gt; (https://example.com)",
  "license":     "some_license_here",
  "private":     true,
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  }
}
EOF
$ npm init -y
$ npm install browserify
</pre></blockquote><p> 
</p><a name="protobuf"></a><center><h4>Protobufjs</h4></center><p>
Библиотека предоставляет парсер
для определения интерфейса <code>.proto</code>,
а также генератор кода для парсинга и генерации сообщений.
</p><p>
В данном примере используется
файл
<a href="https://github.com/grpc/grpc/blob/master/examples/protos/helloworld.proto">helloworld.proto</a>
из примеров gRPC.
Целью является создание двух сообщений:
<code>HelloRequest</code> и
<code>HelloResponse</code>.
Также используется
<a href="https://github.com/protobufjs/protobuf.js/blob/master/README.md#reflection-vs-static-code">статический</a>
режим protobufjs вместо динамически генерируемых классов, так как
njs не поддерживает динамическое добавление новых функций
из соображений безопасности.
</p><p>
Затем устанавливается библиотека,
из определения протокола генерируется код JavaScript,
реализующий маршалинг сообщений:
</p> <blockquote class="example"><pre>
$ npm install protobufjs
$ npx pbjs -t static-module helloworld.proto &gt; static.js
</pre></blockquote><p> 
</p><p>
Таким образом файл <code>static.js</code> становится новой зависимостью,
хранящей необходимый код для реализации обработки сообщений.
Функция <code>set_buffer()</code> содержит код, использующий
библиотеку для создания буфера с сериализованным
сообщением <code>HelloRequest</code>.
Код находится в файле <code>code.js</code>:
</p> <blockquote class="example"><pre>
var pb = require('./static.js');

// Пример использования библиотеки protobuf: подготовка буфера к отправке
function set_buffer(pb)
{
    // назначение полей gRPC payload
    var payload = { name: "TestString" };

    // создание объекта
    var message = pb.helloworld.HelloRequest.create(payload);

    // сериализация объекта в буфер
    var buffer = pb.helloworld.HelloRequest.encode(message).finish();

    var n = buffer.length;

    var frame = new Uint8Array(5 + buffer.length);

    frame[0] = 0;                        // флаг 'compressed'
    frame[1] = (n &amp; 0xFF000000) &gt;&gt;&gt; 24;  // длина: uint32 в сетевом порядке байт
    frame[2] = (n &amp; 0x00FF0000) &gt;&gt;&gt; 16;
    frame[3] = (n &amp; 0x0000FF00) &gt;&gt;&gt;  8;
    frame[4] = (n &amp; 0x000000FF) &gt;&gt;&gt;  0;

    frame.set(buffer, 5);

    return frame;
}

var frame = set_buffer(pb);
</pre></blockquote><p> 
</p><p>
Для проверки работоспособности необходимо выполнить код при помощи node:
</p> <blockquote class="example"><pre>
$ node ./code.js
Uint8Array [
    0,   0,   0,   0,  12, 10,
   10,  84, 101, 115, 116, 83,
  116, 114, 105, 110, 103
]
</pre></blockquote><p> 
Результатом является закодированный фрейм <code>gRPC</code>.
Теперь фрейм можно запустить с njs:
</p> <blockquote class="example"><pre>
$ njs ./code.js
Thrown:
Error: Cannot find module "./static.js"
    at require (native)
    at main (native)
</pre></blockquote><p> 
</p><p>
Так как модули не поддерживаются, то операция завершается получением исключения.
В этом случае можно использовать утилиту <code>browserify</code>
или другую подобную утилиту.
</p><p>
Попытка обработки файла <code>code.js</code> завершится
большим количеством JS-кода, который предполагается запускать в браузере,
то есть сразу после загрузки.
Однако необходимо получить другой результат — 
экспортируемую функцию, на которую
можно сослаться из конфигурации nginx.
Для этого потребуется создание кода-обёртки.
</p> <blockquote class="note">
В целях упрощения в примерах данной статьи
используется <a href="cli.html">интерфейс комадной строки</a> njs.
На практике для запуска кода обычно используется njs-модуль для nginx.
</blockquote><p> 
</p><p>
Файл <code>load.js</code> содержит код, загружающий библиотеку,
храняющую дескриптор в глобальном пространстве имён:
</p> <blockquote class="example"><pre>
global.hello = require('./static.js');
</pre></blockquote><p> 
Данный код будет заменён объединённым содержимым.
Код будет использовать дескриптор "<code>global.hello</code>" для доступа
к библиотеке.
</p><p>
Затем для получения всех зависимостей в один файл
код обрабатыается утилитой <code>browserify</code>:
</p> <blockquote class="example"><pre>
$ npx browserify load.js -o bundle.js -d
</pre></blockquote><p> 
В результате генерируется объёмный файл, содержащий все зависимости:
</p> <blockquote class="example"><pre>
(function(){function......
...
...
},{"protobufjs/minimal":9}]},{},[1])
//# sourceMappingURL..............
</pre></blockquote><p> 
Для получения результирующего файла "<code>njs_bundle.js</code>"
необходимо объединить "<code>bundle.js</code>" и следующий код:
</p> <blockquote class="example"><pre>
// Пример использования библиотеки protobuf: подготовка буфера к отправке
function set_buffer(pb)
{
    // назначение полей gRPC payload
    var payload = { name: "TestString" };

    // создание объекта
    var message = pb.helloworld.HelloRequest.create(payload);

    // сериализация объекта в буфер
    var buffer = pb.helloworld.HelloRequest.encode(message).finish();

    var n = buffer.length;

    var frame = new Uint8Array(5 + buffer.length);

    frame[0] = 0;                        // флаг 'compressed'
    frame[1] = (n &amp; 0xFF000000) &gt;&gt;&gt; 24;  // длина: uint32 в сетевом порядке байт
    frame[2] = (n &amp; 0x00FF0000) &gt;&gt;&gt; 16;
    frame[3] = (n &amp; 0x0000FF00) &gt;&gt;&gt;  8;
    frame[4] = (n &amp; 0x000000FF) &gt;&gt;&gt;  0;

    frame.set(buffer, 5);

    return frame;
}

// функции, вызываемые снаружи
function setbuf()
{
    return set_buffer(global.hello);
}

// вызов кода
var frame = setbuf();
console.log(frame);
</pre></blockquote><p> 
Для проверки работоспособности необходимо запустить файл при помощи node:
</p> <blockquote class="example"><pre>
$ node ./njs_bundle.js
Uint8Array [
    0,   0,   0,   0,  12, 10,
   10,  84, 101, 115, 116, 83,
  116, 114, 105, 110, 103
]
</pre></blockquote><p> 
Дальнейшие шаги выполняются при помощи njs:
</p> <blockquote class="example"><pre>
$ njs ./njs_bundle.js
Uint8Array [0,0,0,0,12,10,10,84,101,115,116,83,116,114,105,110,103]
</pre></blockquote><p> 
Теперь необходимо задействовать njs API для преобразования
массива в байтовую строку для дальнейшего использования модулем nginx.
Данный код необходимо добавить перед строкой
<code>return frame; }</code>:
</p> <blockquote class="example"><pre>
if (global.njs) {
    return String.bytesFrom(frame)
}
</pre></blockquote><p> 
Проверка работоспособности:
</p> <blockquote class="example"><pre>
$ njs ./njs_bundle.js |hexdump -C
00000000  00 00 00 00 0c 0a 0a 54  65 73 74 53 74 72 69 6e  |.......TestStrin|
00000010  67 0a                                             |g.|
00000012
</pre></blockquote><p> 
Экспортируемая функция получена.
Парсинг ответа может быть сделан аналогичным способом:
</p> <blockquote class="example"><pre>
function parse_msg(pb, msg)
{
    // преобразование байтовой строки в массив целых чисел
    var bytes = msg.split('').map(v=&gt;v.charCodeAt(0));

    if (bytes.length &lt; 5) {
        throw 'message too short';
    }

    // первые 5 байт являются фреймом gRPC (сжатие + длина)
    var head = bytes.splice(0, 5);

    // проверка правильной длины сообщения
    var len = (head[1] &lt;&lt; 24)
              + (head[2] &lt;&lt; 16)
              + (head[3] &lt;&lt; 8)
              + head[4];

    if (len != bytes.length) {
        throw 'header length mismatch';
    }

    // вызов protobufjs для декодирования сообщения
    var response = pb.helloworld.HelloReply.decode(bytes);

    console.log('Reply is:' + response.message);
}
</pre></blockquote><p> 
</p><a name="dnspacket"></a><center><h4>Пакет DNS</h4></center><p>
В примере используется библиотека для создания и парсинга пакетов DNS.
Эта библиотека, а также её зависимости,
использует современные языковые конструкции, не поддерживаемые в njs.
Для поддержки таких конструкций
потребуется дополнительный шаг: транспилирование исходного кода.
</p><p>
Необходимо установить дополнительные пакеты node:
</p> <blockquote class="example"><pre>
$ npm install @babel/core @babel/cli @babel/preset-env babel-loader
$ npm install webpack webpack-cli
$ npm install buffer
$ npm install dns-packet
</pre></blockquote><p> 
Файл конфигурации webpack.config.js:
</p> <blockquote class="example"><pre>
const path = require('path');

module.exports = {
    entry: './load.js',
    mode: 'production',
    output: {
        filename: 'wp_out.js',
        path: path.resolve(__dirname, 'dist'),
    },
    optimization: {
        minimize: false
    },
    node: {
        global: true,
    },
    module : {
        rules: [{
            test: /\.m?js$$/,
            exclude: /(bower_components)/,
            use: {
                loader: 'babel-loader',
                options: {
                    presets: ['@babel/preset-env']
                }
            }
        }]
    }
};
</pre></blockquote><p> 
В данном случае используется режим "<code>production</code>".
Конструкция "<code>eval</code>" не используется, так как
не поддерживается njs.
Точкой входа является файл <code>load.js</code>:
</p> <blockquote class="example"><pre>
global.dns = require('dns-packet')
global.Buffer = require('buffer/').Buffer
</pre></blockquote><p> 
Сначала необходимо создать единый файл для библиотек, как в предыдущих примерах:
</p> <blockquote class="example"><pre>
$ npx browserify load.js -o bundle.js -d
</pre></blockquote><p> 
Затем необходимо обработать утилитой webpack, что также запускает babel:
</p> <blockquote class="example"><pre>
$ npx webpack --config webpack.config.js
</pre></blockquote><p> 
Команда создаёт файл <code>dist/wp_out.js</code>, являющийся
трансплицированной версией <code>bundle.js</code>.
Далее необходимо объединить этот файл с <code>code.js</code>,
хранящим код:
</p> <blockquote class="example"><pre>
function set_buffer(dnsPacket)
{
    // create DNS packet bytes
    var buf = dnsPacket.encode({
        type: 'query',
        id: 1,
        flags: dnsPacket.RECURSION_DESIRED,
        questions: [{
            type: 'A',
            name: 'google.com'
        }]
    })

    return buf;
}
</pre></blockquote><p> 
В данном примере генерируемый код не обёрнут в функцию,
явного вызова не требуется.
Результат доступен в каталоге "<code>dist</code>":
</p> <blockquote class="example"><pre>
$ cat dist/wp_out.js code.js &gt; njs_dns_bundle.js
</pre></blockquote><p> 
Далее осуществляется вызов кода в конце файла:
</p> <blockquote class="example"><pre>
var b = set_buffer(global.dns);
console.log(b);
</pre></blockquote><p> 
И затем выполнение кода при помощи node:
</p> <blockquote class="example"><pre>
$ node ./njs_dns_bundle_final.js
Buffer [Uint8Array] [
    0,   1,   1, 0,  0,   1,   0,   0,
    0,   0,   0, 0,  6, 103, 111, 111,
  103, 108, 101, 3, 99, 111, 109,   0,
    0,   1,   0, 1
]
</pre></blockquote><p> 
Тестирование и запуск кода вместе с njs:
</p> <blockquote class="example"><pre>
$ njs ./njs_dns_bundle_final.js
Uint8Array [0,1,1,0,0,1,0,0,0,0,0,0,6,103,111,111,103,108,101,3,99,111,109,0,0,1,0,1]
</pre></blockquote><p> 
</p><p>
Ответ можно распарсить следующим способом:
</p> <blockquote class="example"><pre>
function parse_response(buf)
{
    var bytes = buf.split('').map(v=&gt;v.charCodeAt(0));

    var b = global.Buffer.from(bytes);

    var packet = dnsPacket.decode(b);

    var resolved_name = packet.answers[0].name;

    // ожидаемое имя 'google.com', согласно запросу выше
}
</pre></blockquote><p> 

</p></div></div></body></html>
