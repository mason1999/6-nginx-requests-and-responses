<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Модуль ngx_http_upstream_module</title><style type="text/css">body { background: white; color: black; font-family: sans-serif; line-height: 1.4em; text-align: center; margin: 0; padding: 0; } #banner { background: black; color: #F2F2F2; line-height: 1.2em; padding: .3em 0; box-shadow: 0 5px 10px black; } #banner a { color: #00B140; } #main { text-align: left; margin: 0 auto; min-width: 32em; max-width: 64em; } #menu { float: right; width: 11em; padding: 0 .5em 1em .5em; border-left: 2px solid #DDD; } #content { margin-right: 13.5em; padding: 0 .2em 0 1.5em; } h1 { display: block; font-size: 3em; text-align: left; height: .7em; margin: 0; margin-bottom: .5em; } h1 img { width: 100%; } h2 { text-align: center; } p { text-align: justify; } table.news p { margin-top: 0; } table.news td { vertical-align: baseline; } table.news .date { text-align: right; padding-right: 0.5em; white-space: nowrap; } table.donors td { vertical-align: baseline; } table.donors li { text-align: left; } div.directive { background: #F2F2F2; line-height: 1em; margin: 1em 0 1em -1em; padding: .7em .7em .7em 1em; border-top: 2px solid #DDD; } div.directive th { padding-left: 0; padding-right: .5em; vertical-align: baseline; text-align: left; font-weight: normal; } div.directive td { vertical-align: baseline; } div.directive pre { padding: 0; margin: 0; } div.directive p { margin: .5em 0 0 .1em; font-size: .8em; } a.notrans { color: gray; text-decoration:none; } span.initial { font-size: 200%; float: left; padding-right: 10pt;} ul, ol { margin: .5em 0 1em 1em; padding: 0 .5em; } ol { list-style-position: inside; } li { text-align: justify; padding: .5em 0 0 1px; } .compact li { padding-top: 0; } dl { margin: .5em 0 1em 0; } dt { margin: .5em 0; } .compact dt { margin-bottom: .2em; } dd { margin-left: 1.5em; padding-left: 1px; text-align: justify; } td.list { background: #F2F2F2; } blockquote { margin: 1em 0 1em 1em; padding: .5em; } li blockquote, dd blockquote { margin: .7em 0; } blockquote.note { border: 1px dotted #999; line-height: 1.2em; text-align: justify; } blockquote.example { line-height: 1em; border-left: 1px solid #BBB; } blockquote.example pre { padding: 0; margin: 0; } sup { font-size: 50%; } .video { position: relative; padding-bottom: 56.25%; overflow: hidden; } .video iframe, .video object, .video embed { position: absolute; top:0; left:0; width:100%; height:100%; }</style><script>
        window.addEventListener("load", function(e) {
            fetch("../../../banner/banner.html")
                .then((response) => response.text())
                .then((resp) => {
                    document.getElementById("banner").innerHTML = resp;
                })
                .catch((error) => {
                    console.warn(error);
                });
        });
    </script></head><body><div id="banner"></div><div id="main"><div id="menu"><h1><a href="/"><img src="/nginx.png" alt="nginx"></a></h1><div><a href="../../../en/docs/http/ngx_http_upstream_module.html">english</a><br>русский<br><br><a href="../../../">новости</a> [en]<br><a href="../../../ru/">об nginx</a><br><a href="../../../ru/download.html">скачать</a><br><a href="../../../en/security_advisories.html">безопасность</a> [en]<br><a href="../../../ru/docs/">документация</a><br><a href="../../../ru/docs/faq.html">faq</a><br><a href="../../../en/books.html">книги</a> [en]<br><a href="../../../ru/support.html">поддержка</a><br><br><a href="http://trac.nginx.org/nginx">trac</a><br><a href="http://twitter.com/nginxorg">twitter</a><br><a href="https://www.nginx.com/blog/">blog</a><br><br><a href="https://unit.nginx.org/">unit</a><br><a href="../../../ru/docs/njs/">njs</a><br></div></div><div id="content"><h2>Модуль ngx_http_upstream_module</h2><table width="100%"><tr><td align="left"><a href="#example">Пример конфигурации</a><br><a href="#directives">Директивы</a><br>     <a href="#upstream">upstream</a><br>     <a href="#server">server</a><br>     <a href="#zone">zone</a><br>     <a href="#state">state</a><br>     <a href="#hash">hash</a><br>     <a href="#ip_hash">ip_hash</a><br>     <a href="#keepalive">keepalive</a><br>     <a href="#keepalive_requests">keepalive_requests</a><br>     <a href="#keepalive_time">keepalive_time</a><br>     <a href="#keepalive_timeout">keepalive_timeout</a><br>     <a href="#ntlm">ntlm</a><br>     <a href="#least_conn">least_conn</a><br>     <a href="#least_time">least_time</a><br>     <a href="#queue">queue</a><br>     <a href="#random">random</a><br>     <a href="#resolver">resolver</a><br>     <a href="#resolver_timeout">resolver_timeout</a><br>     <a href="#sticky">sticky</a><br>     <a href="#sticky_cookie_insert">sticky_cookie_insert</a><br><a href="#variables">Встроенные переменные</a><br></td></tr></table>

<a name="summary"></a><p>
Модуль <code>ngx_http_upstream_module</code>
позволяет описывать группы серверов,
которые могут использоваться в директивах
<a href="ngx_http_proxy_module.html#proxy_pass">proxy_pass</a>,
<a href="ngx_http_fastcgi_module.html#fastcgi_pass">fastcgi_pass</a>,
<a href="ngx_http_uwsgi_module.html#uwsgi_pass">uwsgi_pass</a>,
<a href="ngx_http_scgi_module.html#scgi_pass">scgi_pass</a>,
<a href="ngx_http_memcached_module.html#memcached_pass">memcached_pass</a> и
<a href="ngx_http_grpc_module.html#grpc_pass">grpc_pass</a>.
</p>


<a name="example"></a><center><h4>Пример конфигурации</h4></center><p>
</p> <blockquote class="example"><pre>
upstream <strong>backend</strong> {
    server backend1.example.com       weight=5;
    server backend2.example.com:8080;
    server unix:/tmp/backend3;

    server backup1.example.com:8080   backup;
    server backup2.example.com:8080   backup;
}

server {
    location / {
        proxy_pass http://<strong>backend</strong>;
    }
}
</pre></blockquote><p> 
</p><p>
Динамически настраиваемая группа
с периодическими
<a href="ngx_http_upstream_hc_module.html">проверками работоспособности</a>
доступна как часть
<a href="http://nginx.com/products/">коммерческой подписки</a>:
</p> <blockquote class="example"><pre>
resolver 10.0.0.1;

upstream <strong>dynamic</strong> {
    zone upstream_dynamic 64k;

    server backend1.example.com      weight=5;
    server backend2.example.com:8080 fail_timeout=5s slow_start=30s;
    server 192.0.2.1                 max_fails=3;
    server backend3.example.com      resolve;
    server backend4.example.com      service=http resolve;

    server backup1.example.com:8080  backup;
    server backup2.example.com:8080  backup;
}

server {
    location / {
        proxy_pass http://<strong>dynamic</strong>;
        health_check;
    }
}
</pre></blockquote><p> 
</p>


<a name="directives"></a><center><h4>Директивы</h4></center><a name="upstream"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>upstream</strong> <code><i>название</i></code> { ... }</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code><br>
                </td>
                </tr>
            </table></div><p>
Описывает группу серверов.
Серверы могут слушать на разных портах.
Кроме того, можно одновременно использовать серверы,
слушающие на TCP- и UNIX-сокетах.
</p><p>
Пример:
</p> <blockquote class="example"><pre>
upstream backend {
    server backend1.example.com weight=5;
    server 127.0.0.1:8080       max_fails=3 fail_timeout=30s;
    server unix:/tmp/backend3;

    server backup1.example.com  backup;
}
</pre></blockquote><p> 
</p><p>
По умолчанию запросы распределяются по серверам циклически
(в режиме round-robin) с учётом весов серверов.
В вышеприведённом примере каждые 7 запросов будут распределены так:
5 запросов на <code>backend1.example.com</code>
и по одному запросу на второй и третий серверы.
Если при попытке работы с сервером происходит ошибка, то запрос
передаётся следующему серверу, и так далее до тех пор, пока не будут опробованы
все работающие серверы.
Если не удастся получить успешный ответ
ни от одного из серверов, то клиенту будет возвращён результат работы
с последним сервером.
</p><a name="server"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>server</strong> <code><i>адрес</i></code> [<code><i>параметры</i></code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт <code><i>адрес</i></code> и другие <code><i>параметры</i></code>
сервера.
Адрес может быть указан в виде доменного имени или IP-адреса,
и необязательного порта, или в виде пути UNIX-сокета, который
указывается после префикса “<code>unix:</code>”.
Если порт не указан, используется порт 80.
Доменное имя, которому соответствует несколько IP-адресов,
задаёт сразу несколько серверов.
</p><p>
Могут быть заданы следующие параметры:
</p> <dl class="compact">

<dt id="weight">
<code>weight</code>=<code><i>число</i></code>
</dt>
<dd>
задаёт вес сервера, по умолчанию 1.
</dd>

<dt id="max_conns">
<code>max_conns</code>=<code><i>число</i></code>
</dt>
<dd>
ограничивает максимальное <code><i>число</i></code> одновременных активных
соединений к проксируемому серверу (1.11.5).
Значение по умолчанию равно 0 и означает, что ограничения нет.
Если группа не находится в <a href="#zone">зоне разделяемой памяти</a>,
то ограничение работает отдельно для каждого рабочего процесса.
<blockquote class="note">
При включённых <a href="#keepalive">неактивных постоянных</a> соединениях,
нескольких
<a href="../ngx_core_module.html#worker_processes">рабочих процессах</a>
и <a href="#zone">зоне разделяемой памяти</a>,
суммарное число активных и неактивных соединений с проксируемым сервером
может превышать значение <code>max_conns</code>.
</blockquote>
<blockquote class="note">
Начиная с версии 1.5.9 и до версии 1.11.5
этот параметр был доступен как часть
<a href="http://nginx.com/products/">коммерческой подписки</a>.
</blockquote>
</dd>

<dt id="max_fails">
<code>max_fails</code>=<code><i>число</i></code>
</dt>
<dd>
задаёт число неудачных попыток работы с сервером, которые должны произойти
в течение времени, заданного параметром <code>fail_timeout</code>,
чтобы сервер считался недоступным на период времени, также заданный
параметром <code>fail_timeout</code>.
По умолчанию число попыток устанавливается равным 1.
Нулевое значение отключает учёт попыток.
Что считается неудачной попыткой, определяется директивами
<a href="ngx_http_proxy_module.html#proxy_next_upstream">proxy_next_upstream</a>,
<a href="ngx_http_fastcgi_module.html#fastcgi_next_upstream">fastcgi_next_upstream</a>,
<a href="ngx_http_uwsgi_module.html#uwsgi_next_upstream">uwsgi_next_upstream</a>,
<a href="ngx_http_scgi_module.html#scgi_next_upstream">scgi_next_upstream</a>,
<a href="ngx_http_memcached_module.html#memcached_next_upstream">memcached_next_upstream</a> и
<a href="ngx_http_grpc_module.html#grpc_next_upstream">grpc_next_upstream</a>.
</dd>

<dt id="fail_timeout">
<code>fail_timeout</code>=<code><i>время</i></code>
</dt>
<dd>
задаёт
<ul class="compact">

<li>
время, в течение которого должно произойти заданное число неудачных
попыток работы с сервером для того, чтобы сервер считался недоступным;
</li>

<li>
и время, в течение которого сервер будет считаться недоступным.
</li>

</ul>
По умолчанию параметр равен 10 секундам.
</dd>

<dt id="backup">
<code>backup</code>
</dt>
<dd>
помечает сервер как запасной сервер.
На него будут передаваться запросы в случае, если не работают основные серверы.
<blockquote class="note">
Параметр нельзя использовать совместно с
методами балансировки нагрузки
<a href="#hash">hash</a>, <a href="#ip_hash">ip_hash</a> и <a href="#random">random</a>.
</blockquote>
</dd>

<dt id="down">
<code>down</code>
</dt>
<dd>
помечает сервер как постоянно недоступный.
</dd>

</dl><p> 
</p><p>
Кроме того,
следующие параметры доступны как часть
<a href="http://nginx.com/products/">коммерческой подписки</a>:
</p> <dl class="compact">

<dt id="resolve">
<code>resolve</code>
</dt>
<dd>
отслеживает изменения IP-адресов, соответствующих доменному имени сервера,
и автоматически изменяет конфигурацию группы
без необходимости перезапуска nginx (1.5.12).
Группа должна находиться в <a href="#zone">зоне разделяемой памяти</a>.
<p>
Для работы этого параметра
директива <code>resolver</code>
должна быть задана в блоке
<a href="ngx_http_core_module.html#resolver">http</a>
или в соответствующем блоке <a href="#resolver">upstream</a>.
</p>
</dd>

<dt id="route">
<code>route</code>=<code><i>строка</i></code>
</dt>
<dd>
задаёт имя маршрута к серверу.
</dd>

<dt id="service">
<code>service</code>=<code><i>имя</i></code>
</dt>
<dd>
включает преобразование
<a href="https://datatracker.ietf.org/doc/html/rfc2782">SRV</a>-записей
DNS и задаёт <code><i>имя</i></code> сервиса (1.9.13).
Для работы параметра необходимо указать
параметр <a href="#resolve">resolve</a> для сервера
и не указывать порт сервера.
<p>
Если имя сервиса не содержит точку (“<code>.</code>”), то
имя составляется в соответствии с
<a href="https://datatracker.ietf.org/doc/html/rfc2782">RFC</a>
и в префикс службы добавляется протокол TCP.
Например, для получения
SRV-записи <code>_http._tcp.backend.example.com</code>
необходимо указать директиву:
</p> <blockquote class="example"><pre>
server backend.example.com service=http resolve;
</pre></blockquote><p> 
Если имя сервиса содержит одну и более точек, то имя составляется
при помощи соединения префикса службы и имени сервера.
Например, для получения SRV-записей
<code>_http._tcp.backend.example.com</code>
и <code>server1.backend.example.com</code>
необходимо указать директивы:
</p> <blockquote class="example"><pre>
server backend.example.com service=_http._tcp resolve;
server example.com service=server1.backend resolve;
</pre></blockquote><p> 
</p>

<p>
SRV-записи с наивысшим приоритетом
(записи с одинаковым наименьшим значением приоритета)
преобразуются в основные серверы,
остальные SRV-записи преобразуются в запасные серверы.
Если в конфигурации сервера указан параметр <a href="#backup">backup</a>,
высокоприоритетные SRV-записи преобразуются в запасные серверы,
остальные SRV-записи игнорируются.
</p>
</dd>

<dt id="slow_start">
<code>slow_start</code>=<code><i>время</i></code>
</dt>
<dd>
задаёт <code><i>время</i></code>, в течение которого вес сервера
восстановится от нуля до своего номинального значения в ситуации, когда
неработоспособный (unhealthy) сервер вновь становится работоспособным
(<a href="ngx_http_upstream_hc_module.html#health_check">healthy</a>)
или когда сервер становится доступным по прошествии времени,
в течение которого он считался <a href="#fail_timeout">недоступным</a>.
Значение по умолчанию равно нулю и означает, что медленный старт выключен.
<blockquote class="note">
Параметр нельзя использовать совместно с
методами балансировки нагрузки
<a href="#hash">hash</a>, <a href="#ip_hash">ip_hash</a> и <a href="#random">random</a>.
</blockquote>
</dd>

<dt id="drain">
<code>drain</code>
</dt>
<dd>
переводит сервер в режим “draining” (1.13.6).
В этом режиме на сервер будут проксироваться только
<a href="#sticky">привязанные</a> к нему запросы.
<blockquote class="note">
До версии 1.13.6
параметр мог быть изменён только при помощи
модуля <a href="ngx_http_api_module.html">API</a>.
</blockquote>
</dd>

</dl><p> 
</p><p>
</p> <blockquote class="note">
Если в группе только один сервер, параметры <code>max_fails</code>,
<code>fail_timeout</code> и <code>slow_start</code>
игнорируются и такой сервер никогда не будет считаться недоступным.
</blockquote><p> 
</p><a name="zone"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>zone</strong> <code><i>имя</i></code> [<code><i>размер</i></code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.9.0.
            </p></div><p>
Задаёт <code><i>имя</i></code> и <code><i>размер</i></code> зоны разделяемой памяти,
в которой хранятся конфигурация группы и её рабочее состояние,
разделяемые между рабочими процессами.
В одной и той же зоне могут быть сразу несколько групп.
В этом случае достаточно указать <code><i>размер</i></code> только один раз.
</p><p>
Дополнительно, как часть
<a href="http://nginx.com/products/">коммерческой подписки</a>,
в таких группах для изменения состава группы
или настроек отдельных серверов
нет необходимости перезапускать nginx.
Конфигурация доступна через
модуль <a href="ngx_http_api_module.html">API</a> (1.13.3).
</p> <blockquote class="note">
До версии 1.13.3
конфигурация была доступна только через специальный location,
в котором указана директива
<a href="ngx_http_upstream_conf_module.html#upstream_conf">upstream_conf</a>.
</blockquote><p> 
</p><a name="state"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>state</strong> <code><i>файл</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.9.7.
            </p></div><p>
Задаёт <code><i>файл</i></code>, в котором хранится состояние
динамически настраиваемой группы.
</p><p>
Примеры:
</p> <blockquote class="example"><pre>
state /var/lib/nginx/state/servers.conf; # путь для Linux
state /var/db/nginx/state/servers.conf;  # путь для FreeBSD
</pre></blockquote><p> 
</p><p>
В данный момент состояние ограничено списком серверов с их параметрами.
Файл читается при парсинге конфигурации и обновляется каждый раз при
<a href="ngx_http_api_module.html#http_upstreams_http_upstream_name_servers_">изменении</a>
конфигурации группы.
Изменение содержимого файла напрямую не рекомендуется.
Директиву нельзя использовать
совместно с директивой <a href="#server">server</a>.
</p><p>
</p> <blockquote class="note">
Изменения, совершённые в момент
<a href="../control.html#reconfiguration">перезагрузки конфигурации</a>
или <a href="../control.html#upgrade">обновления бинарного файла</a>,
могут быть потеряны.
</blockquote><p> 
</p><p>
</p> <blockquote class="note">
Эта директива доступна как часть
<a href="http://nginx.com/products/">коммерческой подписки</a>.
</blockquote><p> 
</p><a name="hash"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>hash</strong> <code><i>ключ</i></code> [<code>consistent</code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.7.2.
            </p></div><p>
Задаёт метод балансировки нагрузки для группы, при котором
соответствие клиента серверу определяется при помощи
хэшированного значения <code><i>ключа</i></code>.
В качестве <code><i>ключа</i></code> может использоваться
текст, переменные и их комбинации.
Следует отметить, что любое добавление или удаление серверов в группе
может привести к перераспределению большинства ключей на другие серверы.
Метод совместим с библиотекой Perl
<a href="https://metacpan.org/pod/Cache::Memcached">Cache::Memcached</a>.
</p><p>
Если задан параметр <code>consistent</code>, то вместо
вышеописанного метода будет использоваться метод консистентного хэширования
<a href="https://www.metabrew.com/article/libketama-consistent-hashing-algo-memcached-clients">ketama</a>.
Метод гарантирует, что при добавлении сервера в группу или его удалении
на другие серверы будет перераспределено минимальное число ключей.
Применение метода для кэширующих серверов обеспечивает
больший процент попаданий в кэш.
Метод совместим с библиотекой Perl
<a href="https://metacpan.org/pod/Cache::Memcached::Fast">Cache::Memcached::Fast</a>
при значении параметра <code><i>ketama_points</i></code> равным 160.
</p><a name="ip_hash"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>ip_hash</strong>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт для группы метод балансировки нагрузки, при котором запросы
распределяются по серверам на основе IP-адресов клиентов.
В качестве ключа для хэширования используются первые три
октета IPv4-адреса клиента или IPv6-адрес клиента целиком.
Метод гарантирует, что запросы одного и того же клиента
будут всегда передаваться на один и тот же сервер.
Если же этот сервер будет считаться недоступным,
то запросы этого клиента будут передаваться на другой сервер.
С большой долей вероятности это также будет один и тот же сервер.
</p> <blockquote class="note">
IPv6-адреса поддерживаются начиная с версий 1.3.2 и 1.2.2.
</blockquote><p> 
</p><p>
Если один из серверов нужно убрать на некоторое время, то для сохранения
текущего хэширования IP-адресов клиентов этот сервер нужно пометить
параметром <code>down</code>.
</p><p>
Пример:
</p> <blockquote class="example"><pre>
upstream backend {
    ip_hash;

    server backend1.example.com;
    server backend2.example.com;
    server backend3.example.com <strong>down</strong>;
    server backend4.example.com;
}
</pre></blockquote><p> 
</p><p>
</p> <blockquote class="note">
До версий 1.3.1 и 1.2.2 для серверов, использующих метод балансировки нагрузки
<code>ip_hash</code>, нельзя было задать вес.
</blockquote><p> 
</p><a name="keepalive"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>keepalive</strong> <code><i>соединения</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.1.4.
            </p></div><p>
Задействует кэш соединений для группы серверов.
</p><p>
Параметр <code><i>соединения</i></code> устанавливает максимальное число
неактивных постоянных соединений с серверами группы, которые будут
сохраняться в кэше каждого рабочего процесса.
При превышении этого числа наиболее давно не используемые соединения
закрываются.
</p> <blockquote class="note">
Следует особо отметить, что директива <code>keepalive</code>
не ограничивает общее число соединений с серверами группы, которые
рабочие процессы nginx могут открыть.
Параметр <code><i>соединения</i></code> следует устанавливать достаточно
консервативно, чтобы серверы группы по-прежнему могли обрабатывать
новые входящие соединения.
</blockquote><p> 

</p> <blockquote class="note">
При использовании методов балансировки нагрузки, отличных
от стандартного round-robin, следует активировать их до
директивы <code>keepalive</code>.
</blockquote><p> 
</p><p>
Пример конфигурации группы серверов memcached с постоянными соединениями:
</p> <blockquote class="example"><pre>
upstream memcached_backend {
    server 127.0.0.1:11211;
    server 10.0.0.2:11211;

    keepalive 32;
}

server {
    ...

    location /memcached/ {
        set $memcached_key $uri;
        memcached_pass memcached_backend;
    }

}
</pre></blockquote><p> 
</p><p>
Для HTTP директиву
<a href="ngx_http_proxy_module.html#proxy_http_version">proxy_http_version</a>
следует установить в “<code>1.1</code>”,
а поле заголовка “Connection” — очистить:
</p> <blockquote class="example"><pre>
upstream http_backend {
    server 127.0.0.1:8080;

    keepalive 16;
}

server {
    ...

    location /http/ {
        proxy_pass http://http_backend;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        ...
    }
}
</pre></blockquote><p> 
</p><p>
</p> <blockquote class="note">
Хоть это и не рекомендуется, но также возможно использование постоянных
соединений с HTTP/1.0, путём передачи поля заголовка
“Connection: Keep-Alive” серверу группы.
</blockquote><p> 
</p><p>
Для работы постоянных соединений с FastCGI-серверами потребуется
включить директиву
<a href="ngx_http_fastcgi_module.html#fastcgi_keep_conn">fastcgi_keep_conn</a>:
</p> <blockquote class="example"><pre>
upstream fastcgi_backend {
    server 127.0.0.1:9000;

    keepalive 8;
}

server {
    ...

    location /fastcgi/ {
        fastcgi_pass fastcgi_backend;
        fastcgi_keep_conn on;
        ...
    }
}
</pre></blockquote><p> 
</p><p>
</p> <blockquote class="note">
Протоколы SCGI и uwsgi не определяют семантику постоянных соединений.
</blockquote><p> 
</p><a name="keepalive_requests"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>keepalive_requests</strong> <code><i>число</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>keepalive_requests 1000;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.15.3.
            </p></div><p>
Задаёт максимальное число запросов, которые можно
сделать по одному постоянному соединению.
После того как сделано максимальное число запросов,
соединение закрывается.
</p><p>
Периодическое закрытие соединений необходимо для освобождения
памяти, выделенной под конкретные соединения.
Поэтому использование слишком большого максимального числа запросов
может приводить к чрезмерному потреблению памяти и не рекомендуется.
</p><p>
</p> <blockquote class="note">
До версии 1.19.10 по умолчанию использовалось значение 100.
</blockquote><p> 
</p><a name="keepalive_time"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>keepalive_time</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>keepalive_time 1h;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.19.10.
            </p></div><p>
Ограничивает максимальное время, в течение которого
могут обрабатываться запросы в рамках постоянного соединения.
По достижении заданного времени соединение закрывается
после обработки очередного запроса.
</p><a name="keepalive_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>keepalive_timeout</strong> <code><i>таймаут</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>keepalive_timeout 60s;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.15.3.
            </p></div><p>
Задаёт таймаут, в течение которого неактивное постоянное
соединение с сервером группы не будет закрыто.
</p><a name="ntlm"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>ntlm</strong>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.9.2.
            </p></div><p>
Позволяет проксировать запросы с
<a href="https://en.wikipedia.org/wiki/Integrated_Windows_Authentication">проверкой
подлинности NTLM</a>.
Соединение с сервером группы привязывается к клиентскому соединению
как только клиент отправляет запрос, в заголовке которого есть поле
“Authorization” со значением,
начинающимся с “<code>Negotiate</code>” или “<code>NTLM</code>”.
Последующие запросы клиента будут проксироваться через это же соединение
с сервером группы,
сохраняя контекст аутентификации.
</p><p>
Для работы проверки подлинности NTLM
необходимо разрешить постоянные соединения с серверами группы.
Директиву <a href="ngx_http_proxy_module.html#proxy_http_version">proxy_http_version</a>
следует установить в “<code>1.1</code>”,
а поле заголовка “Connection” — очистить:
</p> <blockquote class="example"><pre>
upstream http_backend {
    server 127.0.0.1:8080;

    ntlm;
}

server {
    ...

    location /http/ {
        proxy_pass http://http_backend;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        ...
    }
}
</pre></blockquote><p> 
</p><p>
</p> <blockquote class="note">
При использовании методов балансировки нагрузки, отличных
от стандартного round-robin, следует активировать их до
директивы <code>ntlm</code>.
</blockquote><p> 
</p><p>
</p> <blockquote class="note">
Эта директива доступна как часть
<a href="http://nginx.com/products/">коммерческой подписки</a>.
</blockquote><p> 
</p><a name="least_conn"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>least_conn</strong>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table>
                        <p>
                    Эта директива появилась в версиях 1.3.1 и 1.2.2.
                    
                        </p>
                    </div><p>
Задаёт для группы метод балансировки нагрузки, при котором запрос
передаётся серверу с наименьшим числом активных соединений,
с учётом весов серверов.
Если подходит сразу несколько серверов, они выбираются циклически
(в режиме round-robin) с учётом их весов.
</p><a name="least_time"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>least_time</strong> 
    <code>header</code> |
    <code>last_byte</code>
    [<code>inflight</code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.7.10.
            </p></div><p>
Задаёт для группы метод балансировки нагрузки, при котором запрос
передаётся серверу с наименьшими средним временем ответа и
числом активных соединений с учётом весов серверов.
Если подходит сразу несколько серверов, то они выбираются циклически
(в режиме round-robin) с учётом их весов.
</p><p>
Если указан параметр <code>header</code>,
то учитывается время получения
<a href="#var_upstream_header_time">заголовка ответа</a>.
Если указан параметр <code>last_byte</code>, то учитывается
время получения <a href="#var_upstream_response_time">всего ответа</a>.
Если указан параметр <code>inflight</code> (1.11.6),
то также учитываются незавершённые запросы.
</p> <blockquote class="note">
До версии 1.11.6 незавершённые запросы учитывались по умолчанию.
</blockquote><p> 
</p><p>
</p> <blockquote class="note">
Эта директива доступна как часть
<a href="http://nginx.com/products/">коммерческой подписки</a>.
</blockquote><p> 
</p><a name="queue"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>queue</strong> 
<code><i>число</i></code>
[<code>timeout</code>=<code><i>время</i></code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.5.12.
            </p></div><p>
Если при обработке запроса невозможно сразу выбрать сервер группы, то
запрос будет помещён в очередь.
Директива задаёт максимальное <code><i>число</i></code> запросов,
которые могут одновременно находиться в очереди.
Если очередь переполнена
или за время, задаваемое параметром <code>timeout</code>,
так и не удастся выбрать сервер для передачи ему запроса,
клиенту будет возвращена ошибка
502 (Bad Gateway).
</p><p>
По умолчанию параметр <code>timeout</code> равен 60 секундам.
</p><p>
</p> <blockquote class="note">
При использовании методов балансировки нагрузки, отличных
от стандартного round-robin, следует активировать их до
директивы <code>queue</code>.
</blockquote><p> 

</p> <blockquote class="note">
Эта директива доступна как часть
<a href="http://nginx.com/products/">коммерческой подписки</a>.
</blockquote><p> 
</p><a name="random"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>random</strong> [<code>two</code> [<code><i>метод</i></code>]];</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.15.1.
            </p></div><p>
Задаёт для группы метод балансировки нагрузки, при котором запрос
передаётся случайно выбранному серверу, с учётом весов
серверов.
</p><p>
Если указан необязательный параметр <code>two</code>,
то nginx случайным образом выбирает
<a href="https://homes.cs.washington.edu/~karlin/papers/balls.pdf">два</a>
сервера, из которых выбирает сервер,
используя указанный <code>метод</code>.
Методом по умолчанию является <code>least_conn</code>,
при котором запрос передаётся на сервер
с наименьшим количеством активных соединений.
</p><a name="random_least_time"></a><p>
Если указан метод <code>least_time</code>, то запрос передаётся серверу
с наименьшими средним временем ответа и числом активных соединений.
Если указан <code>least_time=header</code>, то учитывается
время получения <a href="#var_upstream_header_time">заголовка ответа</a>.
Если указан <code>least_time=last_byte</code>, то учитывается
время получения <a href="#var_upstream_response_time">всего ответа</a>.
</p> <blockquote class="note">
Метод <code>least_time</code> доступен как часть
<a href="http://nginx.com/products/">коммерческой подписки</a>.
</blockquote><p> 
</p><a name="resolver"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>resolver</strong> 
    <code><i>адрес</i></code> ...
    [<code>valid</code>=<code><i>время</i></code>]
    [<code>ipv4</code>=<code>on</code>|<code>off</code>]
    [<code>ipv6</code>=<code>on</code>|<code>off</code>]
    [<code>status_zone</code>=<code><i>зона</i></code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.17.5.
            </p></div><p>
Задаёт серверы DNS, используемые для преобразования имён вышестоящих серверов
в адреса, например:
</p> <blockquote class="example"><pre>
resolver 127.0.0.1 [::1]:5353;
</pre></blockquote><p> 
Адрес может быть указан в виде доменного имени или IP-адреса,
и необязательного порта.
Если порт не указан, используется порт 53.
Серверы DNS опрашиваются циклически.
</p><a name="resolver_ipv6"></a><p>
По умолчанию nginx будет искать как IPv4-, так и IPv6-адреса
при преобразовании имён в адреса.
Если поиск IPv4- или IPv6-адресов нежелателен,
можно указать параметр <code>ipv4=off</code> (1.23.1) или
<code>ipv6=off</code>.
</p><a name="resolver_valid"></a><p>
По умолчанию nginx кэширует ответы, используя значение TTL из ответа.
Необязательный параметр <code>valid</code> позволяет это
переопределить:
</p> <blockquote class="example"><pre>
resolver 127.0.0.1 [::1]:5353 valid=30s;
</pre></blockquote><p> 
</p> <blockquote class="note">
Для предотвращения DNS-спуфинга рекомендуется
использовать DNS-серверы в защищённой доверенной локальной сети.
</blockquote><p> 
</p><a name="resolver_status_zone"></a><p>
Необязательный параметр <code>status_zone</code>
включает
<a href="ngx_http_api_module.html#resolvers_">сбор информации</a>
о запросах и ответах сервера DNS
в указанной <code><i>зоне</i></code>.
</p><p>
</p> <blockquote class="note">
Эта директива доступна как часть
<a href="http://nginx.com/products/">коммерческой подписки</a>.
</blockquote><p> 
</p><a name="resolver_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>resolver_timeout</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>resolver_timeout 30s;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.17.5.
            </p></div><p>
Задаёт таймаут для преобразования имени в адрес, например:
</p> <blockquote class="example"><pre>
resolver_timeout 5s;
</pre></blockquote><p> 
</p><p>
</p> <blockquote class="note">
Эта директива доступна как часть
<a href="http://nginx.com/products/">коммерческой подписки</a>.
</blockquote><p> 
</p><a name="sticky"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>sticky</strong> 
    <code>cookie</code> <code><i>имя</i></code>
    [<code>expires=</code><code><i>время</i></code>]
    [<code>domain=</code><code><i>домен</i></code>]
    [<code>httponly</code>]
    [<code>samesite=</code><code>strict</code>|<code>lax</code>|<code>none</code>|<code><i>$переменная</i></code>]
    [<code>secure</code>]
    [<code>path=</code><code><i>путь</i></code>];</code><br><code><strong>sticky</strong> 
    <code>route</code> <code><i>$переменная</i></code> ...;</code><br><code><strong>sticky</strong> 
    <code>learn</code>
    <code>create=</code><code><i>$переменная</i></code>
    <code>lookup=</code><code><i>$переменная</i></code>
    <code>zone=</code><code><i>имя</i></code>:<code><i>размер</i></code>
    [<code>timeout=</code><code><i>время</i></code>]
    [<code>header</code>]
    [<code>sync</code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.5.7.
            </p></div><p>
Включает режим привязки сеансов, в котором запросы клиента
будут передаваться на один и тот же сервер группы.
Доступны три метода:
</p> <dl class="compact">
<dt id="sticky_cookie"><code>cookie</code></dt>
<dd>

<p>
При использовании метода <code>cookie</code> информация о
назначенном сервере передаётся в HTTP-куке:
</p> <blockquote class="example"><pre>
upstream backend {
    server backend1.example.com;
    server backend2.example.com;

    sticky cookie srv_id expires=1h domain=.example.com path=/;
}
</pre></blockquote><p> 
</p>

<p>
Запрос от клиента, ещё не привязанного к определённому серверу,
передаётся на сервер, выбранный согласно настроенному методу балансировки.
Дальнейшие запросы от этого клиента передаются на тот же сервер.
Если назначенный сервер не может обработать запрос, выбирается новый
сервер как если бы клиент не имел привязки к серверу.

</p> <blockquote class="note">
Так как любой метод балансировки пытается равномерно распределить нагрузку,
учитывая уже привязанные запросы,
сервер с наибольшим количеством привязанных запросов
имеет меньшую вероятность получить новые, не привязанные запросы.
</blockquote><p> 
</p>

<p>
Первый параметр задаёт имя куки, которую необходимо установить или проверить.
Значением куки является MD5-хэш IP-адреса и порта
(или пути UNIX-сокета) в шестнадцатеричном виде.
Однако если указан параметр “<code>route</code>”
директивы <a href="#server">server</a>, то значением куки будет
значение параметра “<code>route</code>”:
</p> <blockquote class="example"><pre>
upstream backend {
    server backend1.example.com route=<strong>a</strong>;
    server backend2.example.com route=<strong>b</strong>;

    sticky cookie srv_id expires=1h domain=.example.com path=/;
}
</pre></blockquote><p> 
В этом случае значение куки “<code>srv_id</code>” будет
или <code><i>a</i></code>, или <code><i>b</i></code>.
</p>

<p>
Дополнительные параметры могут быть следующими:
</p> <dl class="compact">

<dt><code>expires=</code><code><i>время</i></code></dt>
<dd>
Задаёт <code><i>время</i></code>, в течение которого браузеру необходимо хранить куку.
Специальное значение <code>max</code> устанавливает срок хранения куки до
31 декабря 2037 года 23:55:55 GMT.
Если параметр не указан, то время действия куки ограничивается сессией браузера.
</dd>

<dt><code>domain=</code><code><i>домен</i></code></dt>
<dd>
Задаёт <code><i>домен</i></code>, для которого устанавливается кука.
В значении параметра можно использовать переменные (1.11.5).
</dd>

<dt><code>httponly</code></dt>
<dd>
Добавляет атрибут <code>HttpOnly</code> к куке (1.7.11).
</dd>

<dt id="sticky_samesite"><code>samesite=</code><code>strict</code> |
<code>lax</code> | <code>none</code> | <code>$переменная</code></dt>
<dd>
Добавляет атрибут <code>SameSite</code> (1.19.4) к куке
с одним из следующих значений:
<code>Strict</code>,
<code>Lax</code>,
<code>None</code> или
при помощи переменных (1.23.3).
В последнем случае если переменная имеет пустое значение,
то атрибут <code>SameSite</code> не будет добавлен к куке,
если значение переменной равно
<code>Strict</code>,
<code>Lax</code> или
<code>None</code>,
то атрибуту будет назначено соответствующее значение,
иначе атрибуту будет назначено значение <code>Strict</code>.
</dd>

<dt><code>secure</code></dt>
<dd>
Добавляет атрибут <code>Secure</code> к куке (1.7.11).
</dd>

<dt><code>path=</code><code><i>путь</i></code></dt>
<dd>
Задаёт <code><i>путь</i></code>, для которого устанавливается кука.
</dd>

</dl><p> 
Если пропущен тот или иной параметр, то соответствующего поля в куке не будет.
</p>
</dd>

<dt id="sticky_route"><code>route</code></dt>
<dd>

<p>
При использовании метода <code>route</code> проксируемый сервер назначает
клиенту маршрут по получении первого запроса.
Все последующие запросы от этого клиента будут содержать информацию о
маршруте в куке или URI.
Эта информация сравнивается с параметром “<code>route</code>” директивы
<a href="#server">server</a> для идентификации сервера, на который
следует проксировать запрос.
Если параметр “<code>route</code>” не задан, то именем маршрута
будет являться MD5-хэш IP-адреса и порта
(или пути UNIX-сокета) в шестнадцатеричном виде.
Если назначенный сервер не может обработать запрос, выбирается новый сервер
согласно настроенному методу балансировки как если бы в запросе не было
информации о маршруте.
</p>

<p>
Параметры метода <code>route</code> задают переменные, которые
могут содержать информацию о маршруте.
Первая непустая переменная используется для поиска соответствующего сервера.
</p>

<p>
Пример:
</p> <blockquote class="example"><pre>
map $cookie_jsessionid $route_cookie {
    ~.+\.(?P&lt;route&gt;\w+)$ $route;
}

map $request_uri $route_uri {
    ~jsessionid=.+\.(?P&lt;route&gt;\w+)$ $route;
}

upstream backend {
    server backend1.example.com route=a;
    server backend2.example.com route=b;

    sticky route $route_cookie $route_uri;
}
</pre></blockquote><p> 
В этом примере маршрут берётся из куки “<code>JSESSIONID</code>”,
если она присутствует в запросе.
В противном случае используется маршрут из URI.
</p>

</dd>

<dt id="sticky_learn"><code>learn</code></dt>
<dd>
<p>
При использовании метода <code>learn</code> (1.7.1) nginx
анализирует ответы от вышестоящего сервера и запоминает
начатые им сессии, которые обычно передаются в HTTP-куке.
</p> <blockquote class="example"><pre>
upstream backend {
   server backend1.example.com:8080;
   server backend2.example.com:8081;

   sticky learn
          create=$upstream_cookie_examplecookie
          lookup=$cookie_examplecookie
          zone=client_sessions:1m;
}
</pre></blockquote><p> 

В примере выше сервер группы создаёт сессию путём установки
куки “<code>EXAMPLECOOKIE</code>” в своём ответе.
Последующие запросы с этой кукой будут передаваться на этот же сервер.
Если сервер не может обработать запрос, выбирается новый
сервер как если бы клиент не имел привязки к серверу.
</p>

<p>
Параметры <code>create</code> и <code>lookup</code>
задают переменные, в которых соответственно указывается способ
создания новых и поиска существующих сессий.
Оба параметра могут быть указаны больше одного раза
(в этом случае используется первая непустая переменная).
</p>

<p>
Сессии хранятся в зоне разделяемой памяти, <code><i>имя</i></code> и
<code><i>размер</i></code> которой задаются параметром <code>zone</code>.
Зоны размером в 1 мегабайт достаточно для хранения около 4 тысяч сессий
на 64-битной платформе.
Сессии, к которым не было обращений в течение времени, заданного параметром
<code>timeout</code>, удаляются из зоны.
По умолчанию <code>timeout</code> равен 10 минутам.
</p>

<a name="sticky_learn_header"></a><p>
Параметр <code>header</code> (1.13.1) позволяет создавать сессию
сразу после получения заголовков ответа от сервера группы.
</p>

<a name="sticky_learn_sync"></a><p>
Параметр <code>sync</code> (1.13.8) разрешает
<a href="../stream/ngx_stream_zone_sync_module.html#zone_sync">синхронизацию</a>
данной зоны разделяемой памяти.
</p>

</dd>
</dl><p> 
</p><p>
</p> <blockquote class="note">
Эта директива доступна как часть
<a href="http://nginx.com/products/">коммерческой подписки</a>.
</blockquote><p> 
</p><a name="sticky_cookie_insert"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>sticky_cookie_insert</strong> <code><i>имя</i></code>
[<code>expires=</code><code><i>время</i></code>]
[<code>domain=</code><code><i>домен</i></code>]
[<code>path=</code><code><i>путь</i></code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>upstream</code><br>
                </td>
                </tr>
            </table></div><p>
Эта директива устарела начиная с версии 1.5.7.
Вместо неё следует использовать аналогичную директиву
<a href="#sticky">sticky</a> с изменённым синтаксисом:
</p> <blockquote class="note">
<code>sticky cookie</code> <code><i>имя</i></code>
[<code>expires=</code><code><i>время</i></code>]
[<code>domain=</code><code><i>домен</i></code>]
[<code>path=</code><code><i>путь</i></code>];
</blockquote><p> 
</p>


<a name="variables"></a><center><h4>Встроенные переменные</h4></center><p>
Модуль <code>ngx_http_upstream_module</code>
поддерживает следующие встроенные переменные:
</p> <dl class="compact">

<dt id="var_upstream_addr"><code>$upstream_addr</code></dt>
<dd>
хранит IP-адрес и порт или путь к UNIX-сокету сервера группы.
Если при обработке запроса были сделаны обращения к нескольким серверам,
то их адреса разделяются запятой, например,
“<code>192.168.1.1:80, 192.168.1.2:80, unix:/tmp/sock</code>”.
Если произошло внутреннее перенаправление от одной группы серверов на другую
с помощью
“X-Accel-Redirect” или
<a href="ngx_http_core_module.html#error_page">error_page</a>,
то адреса, соответствующие разным группам серверов, разделяются двоеточием,
например,
“<code>192.168.1.1:80, 192.168.1.2:80, unix:/tmp/sock : 192.168.10.1:80, 192.168.10.2:80</code>”.
Если сервер не может быть выбран,
то переменная хранит имя группы серверов.
</dd>

<dt id="var_upstream_bytes_received"><code>$upstream_bytes_received</code></dt>
<dd>
число байт, полученных от сервера группы (1.11.4).
Значения нескольких соединений
разделяются запятыми и двоеточиями подобно адресам в переменной
<a href="#var_upstream_addr">$upstream_addr</a>.
</dd>

<dt id="var_upstream_bytes_sent"><code>$upstream_bytes_sent</code></dt>
<dd>
число байт, переданных на сервер группы (1.15.8).
Значения нескольких соединений
разделяются запятыми и двоеточиями подобно адресам в переменной
<a href="#var_upstream_addr">$upstream_addr</a>.
</dd>

<dt id="var_upstream_cache_status"><code>$upstream_cache_status</code>
</dt>
<dd>
хранит статус доступа к кэшу ответов (0.8.3).
Статус может быть одним из “<code>MISS</code>”,
“<code>BYPASS</code>”, “<code>EXPIRED</code>”,
“<code>STALE</code>”, “<code>UPDATING</code>”,
“<code>REVALIDATED</code>” или “<code>HIT</code>”.
</dd>

<dt id="var_upstream_connect_time"><code>$upstream_connect_time</code>
</dt>
<dd>
хранит время, затраченное на установление соединения с сервером группы (1.9.1);
время хранится в секундах с точностью до миллисекунд.
В случае SSL, включает в себя время, потраченное на handshake.
Времена нескольких соединений
разделяются запятыми и двоеточиями подобно адресам в переменной
<a href="#var_upstream_addr">$upstream_addr</a>.
</dd>

<dt id="var_upstream_cookie_"><code>$upstream_cookie_</code><code><i>имя</i></code>
</dt>
<dd>
кука с указанным <code><i>именем</i></code>, переданная сервером группы
в поле “Set-Cookie” заголовка ответа (1.7.1).
Необходимо иметь в виду, что куки запоминаются только из ответа
последнего сервера.
</dd>

<dt id="var_upstream_header_time"><code>$upstream_header_time</code>
</dt>
<dd>
хранит время,
затраченное на получение заголовка ответа от сервера группы (1.7.10);
время хранится в секундах с точностью до миллисекунд.
Времена нескольких ответов
разделяются запятыми и двоеточиями подобно адресам в переменной
<a href="#var_upstream_addr">$upstream_addr</a>.
</dd>

<dt id="var_upstream_http_"><code>$upstream_http_</code><code><i>имя</i></code></dt>
<dd>
хранят поля заголовка ответа сервера.
Например, поле заголовка ответа “Server”
доступно в переменной <code>$upstream_http_server</code>.
Правила преобразования имён полей заголовка ответа в имена переменных
такие же, как для переменных с префиксом
“<a href="ngx_http_core_module.html#var_http_">$http_</a>”.
Необходимо иметь в виду, что поля заголовка запоминаются только из ответа
последнего сервера.
</dd>

<dt id="var_upstream_queue_time"><code>$upstream_queue_time</code></dt>
<dd>
хранит время, проведённое запросом в <a href="#queue">очереди</a>
(1.13.9);
время хранится в секундах с точностью до миллисекунд.
Времена нескольких ответов
разделяются запятыми и двоеточиями подобно адресам в переменной
<a href="#var_upstream_addr">$upstream_addr</a>.
</dd>

<dt id="var_upstream_response_length"><code>$upstream_response_length</code>
</dt>
<dd>
хранит длину ответа, полученного от сервера группы (0.7.27);
длина хранится в байтах.
Длины нескольких ответов
разделяются запятыми и двоеточиями подобно адресам в переменной
<a href="#var_upstream_addr">$upstream_addr</a>.
</dd>

<dt id="var_upstream_response_time"><code>$upstream_response_time</code>
</dt>
<dd>
хранит время, затраченное на получение ответа от сервера группы;
время хранится в секундах с точностью до миллисекунд.
Времена нескольких ответов
разделяются запятыми и двоеточиями подобно адресам в переменной
<a href="#var_upstream_addr">$upstream_addr</a>.
</dd>

<dt id="var_upstream_status"><code>$upstream_status</code></dt>
<dd>
хранит статус ответа, полученного от сервера группы.
Статусы нескольких ответов
разделяются запятыми и двоеточиями подобно адресам в переменной
<a href="#var_upstream_addr">$upstream_addr</a>.
Если сервер не может быть выбран, то
переменная хранит статус 502 (Bad Gateway).
</dd>

<dt id="var_upstream_trailer_"><code>$upstream_trailer_</code><code><i>имя</i></code></dt>
<dd>
хранит поля из конца ответа,
полученного от сервера группы (1.13.10).
</dd>

</dl><p> 
</p>

</div></div></body></html>
