<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Модуль ngx_http_core_module</title><style type="text/css">body { background: white; color: black; font-family: sans-serif; line-height: 1.4em; text-align: center; margin: 0; padding: 0; } #banner { background: black; color: #F2F2F2; line-height: 1.2em; padding: .3em 0; box-shadow: 0 5px 10px black; } #banner a { color: #00B140; } #main { text-align: left; margin: 0 auto; min-width: 32em; max-width: 64em; } #menu { float: right; width: 11em; padding: 0 .5em 1em .5em; border-left: 2px solid #DDD; } #content { margin-right: 13.5em; padding: 0 .2em 0 1.5em; } h1 { display: block; font-size: 3em; text-align: left; height: .7em; margin: 0; margin-bottom: .5em; } h1 img { width: 100%; } h2 { text-align: center; } p { text-align: justify; } table.news p { margin-top: 0; } table.news td { vertical-align: baseline; } table.news .date { text-align: right; padding-right: 0.5em; white-space: nowrap; } table.donors td { vertical-align: baseline; } table.donors li { text-align: left; } div.directive { background: #F2F2F2; line-height: 1em; margin: 1em 0 1em -1em; padding: .7em .7em .7em 1em; border-top: 2px solid #DDD; } div.directive th { padding-left: 0; padding-right: .5em; vertical-align: baseline; text-align: left; font-weight: normal; } div.directive td { vertical-align: baseline; } div.directive pre { padding: 0; margin: 0; } div.directive p { margin: .5em 0 0 .1em; font-size: .8em; } a.notrans { color: gray; text-decoration:none; } span.initial { font-size: 200%; float: left; padding-right: 10pt;} ul, ol { margin: .5em 0 1em 1em; padding: 0 .5em; } ol { list-style-position: inside; } li { text-align: justify; padding: .5em 0 0 1px; } .compact li { padding-top: 0; } dl { margin: .5em 0 1em 0; } dt { margin: .5em 0; } .compact dt { margin-bottom: .2em; } dd { margin-left: 1.5em; padding-left: 1px; text-align: justify; } td.list { background: #F2F2F2; } blockquote { margin: 1em 0 1em 1em; padding: .5em; } li blockquote, dd blockquote { margin: .7em 0; } blockquote.note { border: 1px dotted #999; line-height: 1.2em; text-align: justify; } blockquote.example { line-height: 1em; border-left: 1px solid #BBB; } blockquote.example pre { padding: 0; margin: 0; } sup { font-size: 50%; } .video { position: relative; padding-bottom: 56.25%; overflow: hidden; } .video iframe, .video object, .video embed { position: absolute; top:0; left:0; width:100%; height:100%; }</style><script>
        window.addEventListener("load", function(e) {
            fetch("../../../banner/banner.html")
                .then((response) => response.text())
                .then((resp) => {
                    document.getElementById("banner").innerHTML = resp;
                })
                .catch((error) => {
                    console.warn(error);
                });
        });
    </script></head><body><div id="banner"></div><div id="main"><div id="menu"><h1><a href="/"><img src="/nginx.png" alt="nginx"></a></h1><div><a href="../../../en/docs/http/ngx_http_core_module.html">english</a><br>русский<br><br><a href="../../../">новости</a> [en]<br><a href="../../../ru/">об nginx</a><br><a href="../../../ru/download.html">скачать</a><br><a href="../../../en/security_advisories.html">безопасность</a> [en]<br><a href="../../../ru/docs/">документация</a><br><a href="../../../ru/docs/faq.html">faq</a><br><a href="../../../en/books.html">книги</a> [en]<br><a href="../../../ru/support.html">поддержка</a><br><br><a href="http://trac.nginx.org/nginx">trac</a><br><a href="http://twitter.com/nginxorg">twitter</a><br><a href="https://www.nginx.com/blog/">blog</a><br><br><a href="https://unit.nginx.org/">unit</a><br><a href="../../../ru/docs/njs/">njs</a><br></div></div><div id="content"><h2>Модуль ngx_http_core_module</h2><table width="100%"><tr><td align="left"><a href="#directives">Директивы</a><br>     <a href="#absolute_redirect">absolute_redirect</a><br>     <a href="#aio">aio</a><br>     <a href="#aio_write">aio_write</a><br>     <a href="#alias">alias</a><br>     <a href="#auth_delay">auth_delay</a><br>     <a href="#chunked_transfer_encoding">chunked_transfer_encoding</a><br>     <a href="#client_body_buffer_size">client_body_buffer_size</a><br>     <a href="#client_body_in_file_only">client_body_in_file_only</a><br>     <a href="#client_body_in_single_buffer">client_body_in_single_buffer</a><br>     <a href="#client_body_temp_path">client_body_temp_path</a><br>     <a href="#client_body_timeout">client_body_timeout</a><br>     <a href="#client_header_buffer_size">client_header_buffer_size</a><br>     <a href="#client_header_timeout">client_header_timeout</a><br>     <a href="#client_max_body_size">client_max_body_size</a><br>     <a href="#connection_pool_size">connection_pool_size</a><br>     <a href="#default_type">default_type</a><br>     <a href="#directio">directio</a><br>     <a href="#directio_alignment">directio_alignment</a><br>     <a href="#disable_symlinks">disable_symlinks</a><br>     <a href="#error_page">error_page</a><br>     <a href="#etag">etag</a><br>     <a href="#http">http</a><br>     <a href="#if_modified_since">if_modified_since</a><br>     <a href="#ignore_invalid_headers">ignore_invalid_headers</a><br>     <a href="#internal">internal</a><br>     <a href="#keepalive_disable">keepalive_disable</a><br>     <a href="#keepalive_requests">keepalive_requests</a><br>     <a href="#keepalive_time">keepalive_time</a><br>     <a href="#keepalive_timeout">keepalive_timeout</a><br>     <a href="#large_client_header_buffers">large_client_header_buffers</a><br>     <a href="#limit_except">limit_except</a><br>     <a href="#limit_rate">limit_rate</a><br>     <a href="#limit_rate_after">limit_rate_after</a><br>     <a href="#lingering_close">lingering_close</a><br>     <a href="#lingering_time">lingering_time</a><br>     <a href="#lingering_timeout">lingering_timeout</a><br>     <a href="#listen">listen</a><br>     <a href="#location">location</a><br>     <a href="#log_not_found">log_not_found</a><br>     <a href="#log_subrequest">log_subrequest</a><br>     <a href="#max_ranges">max_ranges</a><br>     <a href="#merge_slashes">merge_slashes</a><br>     <a href="#msie_padding">msie_padding</a><br>     <a href="#msie_refresh">msie_refresh</a><br>     <a href="#open_file_cache">open_file_cache</a><br>     <a href="#open_file_cache_errors">open_file_cache_errors</a><br>     <a href="#open_file_cache_min_uses">open_file_cache_min_uses</a><br>     <a href="#open_file_cache_valid">open_file_cache_valid</a><br>     <a href="#output_buffers">output_buffers</a><br>     <a href="#port_in_redirect">port_in_redirect</a><br>     <a href="#postpone_output">postpone_output</a><br>     <a href="#read_ahead">read_ahead</a><br>     <a href="#recursive_error_pages">recursive_error_pages</a><br>     <a href="#request_pool_size">request_pool_size</a><br>     <a href="#reset_timedout_connection">reset_timedout_connection</a><br>     <a href="#resolver">resolver</a><br>     <a href="#resolver_timeout">resolver_timeout</a><br>     <a href="#root">root</a><br>     <a href="#satisfy">satisfy</a><br>     <a href="#send_lowat">send_lowat</a><br>     <a href="#send_timeout">send_timeout</a><br>     <a href="#sendfile">sendfile</a><br>     <a href="#sendfile_max_chunk">sendfile_max_chunk</a><br>     <a href="#server">server</a><br>     <a href="#server_name">server_name</a><br>     <a href="#server_name_in_redirect">server_name_in_redirect</a><br>     <a href="#server_names_hash_bucket_size">server_names_hash_bucket_size</a><br>     <a href="#server_names_hash_max_size">server_names_hash_max_size</a><br>     <a href="#server_tokens">server_tokens</a><br>     <a href="#subrequest_output_buffer_size">subrequest_output_buffer_size</a><br>     <a href="#tcp_nodelay">tcp_nodelay</a><br>     <a href="#tcp_nopush">tcp_nopush</a><br>     <a href="#try_files">try_files</a><br>     <a href="#types">types</a><br>     <a href="#types_hash_bucket_size">types_hash_bucket_size</a><br>     <a href="#types_hash_max_size">types_hash_max_size</a><br>     <a href="#underscores_in_headers">underscores_in_headers</a><br>     <a href="#variables_hash_bucket_size">variables_hash_bucket_size</a><br>     <a href="#variables_hash_max_size">variables_hash_max_size</a><br><a href="#variables">Встроенные переменные</a><br></td></tr></table>

<a name="directives"></a><center><h4>Директивы</h4></center><a name="absolute_redirect"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>absolute_redirect</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>absolute_redirect on;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.11.8.
            </p></div><p>
Если запрещено, то перенаправления, выдаваемые nginx’ом, будут относительными.
</p><p>
См. также директивы <a href="#server_name_in_redirect">server_name_in_redirect</a>
и <a href="#port_in_redirect">port_in_redirect</a>.
</p><a name="aio"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>aio</strong> 
    <code>on</code> |
    <code>off</code> |
    <code>threads</code>[<code>=</code><code><i>pool</i></code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>aio off;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 0.8.11.
            </p></div><p>
Разрешает или запрещает использование файлового асинхронного ввода-вывода (AIO)
во FreeBSD и Linux:
</p> <blockquote class="example"><pre>
location /video/ {
    aio            on;
    output_buffers 1 64k;
}
</pre></blockquote><p> 
</p><p>
Во FreeBSD AIO можно использовать, начиная с FreeBSD 4.3.
До FreeBSD 11.0
AIO можно либо собрать в ядре статически:
</p> <blockquote class="example"><pre>
options VFS_AIO
</pre></blockquote><p> 
либо загрузить динамически через загружаемый модуль ядра:
</p> <blockquote class="example"><pre>
kldload aio
</pre></blockquote><p> 
</p><p>
В Linux AIO можно использовать только начиная с версии ядра 2.6.22.
Кроме того, необходимо также дополнительно включить
<a href="#directio">directio</a>,
иначе чтение будет блокирующимся:
</p> <blockquote class="example"><pre>
location /video/ {
    aio            on;
    directio       512;
    output_buffers 1 128k;
}
</pre></blockquote><p> 
</p><p>
В Linux
<a href="#directio">directio</a>
можно использовать только для чтения блоков, выравненных
на границу 512 байт (или 4К для XFS).
Невыравненный конец файла будет читаться блокированно.
То же относится к запросам с указанием диапазона запрашиваемых байт
(byte-range requests) и к запросам FLV не с начала файла: чтение
невыравненных начала и конца ответа будет блокирующимся.
</p><p>
При одновременном включении AIO и <a href="#sendfile">sendfile</a> в Linux
для файлов, размер которых больше либо равен указанному
в директиве <a href="#directio">directio</a>, будет использоваться AIO,
а для файлов меньшего размера
или при выключенном <a href="#directio">directio</a> — <a href="#sendfile">sendfile</a>:
</p> <blockquote class="example"><pre>
location /video/ {
    sendfile       on;
    aio            on;
    directio       8m;
}
</pre></blockquote><p> 
</p><p>
Кроме того, читать и <a href="#sendfile">отправлять</a>
файлы можно в многопоточном режиме (1.7.11),
не блокируя при этом рабочий процесс:
</p> <blockquote class="example"><pre>
location /video/ {
    sendfile       on;
    aio            threads;
}
</pre></blockquote><p> 
Операции чтения или отправки файлов будут обрабатываться потоками из указанного
<a href="../ngx_core_module.html#thread_pool">пула</a>.
Если пул потоков не задан явно,
используется пул с именем “<code>default</code>”.
Имя пула может быть задано при помощи переменных:
</p> <blockquote class="example"><pre>
aio threads=pool$disk;
</pre></blockquote><p> 
По умолчанию поддержка многопоточности выключена, её сборку следует
разрешить с помощью конфигурационного параметра
<code>--with-threads</code>.
В настоящий момент многопоточность совместима только с методами
<a href="../events.html#epoll">epoll</a>,
<a href="../events.html#kqueue">kqueue</a>
и
<a href="../events.html#eventport">eventport</a>.
Отправка файлов в многопоточном режиме поддерживается только на Linux.
</p><p>
См. также директиву <a href="#sendfile">sendfile</a>.
</p><a name="aio_write"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>aio_write</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>aio_write off;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.9.13.
            </p></div><p>
При включённом <a href="#aio">aio</a> разрешает его использование для записи файлов.
В настоящий момент это работает только при использовании
<code>aio threads</code>
и ограничено записью временных файлов с данными,
полученными от проксируемых серверов.
</p><a name="alias"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>alias</strong> <code><i>путь</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт замену для указанного location’а.
Например, при такой конфигурации
</p> <blockquote class="example"><pre>
location /i/ {
    alias /data/w3/images/;
}
</pre></blockquote><p> 
на запрос
“<code>/i/top.gif</code>” будет отдан файл
<code>/data/w3/images/top.gif</code>.
</p><p>
В значении параметра <code><i>путь</i></code> можно использовать переменные,
кроме <code>$document_root</code> и <code>$realpath_root</code>.
</p><p>
Если <code>alias</code> используется внутри location’а, заданного
регулярным выражением, то регулярное выражение должно содержать
выделения, а сам <code>alias</code> — ссылки на эти выделения
(0.7.40), например:
</p> <blockquote class="example"><pre>
location ~ ^/users/(.+\.(?:gif|jpe?g|png))$ {
    alias /data/w3/images/$1;
}
</pre></blockquote><p> 
</p><p>
Если location и последняя часть значения директивы совпадают:
</p> <blockquote class="example"><pre>
location /images/ {
    alias /data/w3/images/;
}
</pre></blockquote><p> 
то лучше воспользоваться директивой
<a href="#root">root</a>:
</p> <blockquote class="example"><pre>
location /images/ {
    root /data/w3;
}
</pre></blockquote><p> 
</p><a name="auth_delay"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>auth_delay</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>auth_delay 0s;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.17.10.
            </p></div><p>
Задерживает обработку неавторизованных запросов с кодом ответа 401
для предотвращения атак по времени в случае ограничения доступа по
<a href="ngx_http_auth_basic_module.html">паролю</a>, по
<a href="ngx_http_auth_request_module.html">результату подзапроса</a>
или по <a href="ngx_http_auth_jwt_module.html">JWT</a>.
</p><a name="chunked_transfer_encoding"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>chunked_transfer_encoding</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>chunked_transfer_encoding on;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Позволяет запретить формат передачи данных частями (chunked transfer
encoding) в HTTP/1.1.
Это может понадобиться при использовании программ, не поддерживающих
chunked encoding, несмотря на требования стандарта.
</p><a name="client_body_buffer_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>client_body_buffer_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>client_body_buffer_size 8k|16k;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт размер буфера для чтения тела запроса клиента.
Если тело запроса больше заданного буфера,
то всё тело запроса или только его часть записывается во
<a href="#client_body_temp_path">временный файл</a>.
По умолчанию размер одного буфера равен двум размерам страницы.
На x86, других 32-битных платформах и x86-64 это 8K.
На других 64-битных платформах это обычно 16K.
</p><a name="client_body_in_file_only"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>client_body_in_file_only</strong> 
    <code>on</code> |
    <code>clean</code> |
    <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>client_body_in_file_only off;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Определяет, сохранять ли всё тело запроса клиента в файл.
Директиву можно использовать для отладки и при использовании переменной
<code>$request_body_file</code>
или метода
<a href="ngx_http_perl_module.html#methods">$r-&gt;request_body_file</a>
модуля
<a href="ngx_http_perl_module.html">ngx_http_perl_module</a>.
</p><p>
При установке значения <code>on</code> временные файлы
по окончании обработки запроса не удаляются.
</p><p>
Значение <code>clean</code> разрешает удалять временные файлы,
оставшиеся по окончании обработки запроса.
</p><a name="client_body_in_single_buffer"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>client_body_in_single_buffer</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>client_body_in_single_buffer off;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Определяет, сохранять ли всё тело запроса клиента в одном буфере.
Директива рекомендуется при использовании переменной
<code>$request_body</code>
для уменьшения требуемого числа операций копирования.
</p><a name="client_body_temp_path"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>client_body_temp_path</strong> 
    <code><i>путь</i></code>
    [<code><i>уровень1</i></code>
    [<code><i>уровень2</i></code>
    [<code><i>уровень3</i></code>]]];</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>client_body_temp_path client_body_temp;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт каталог для хранения временных файлов с телами запросов клиентов.
В каталоге может использоваться иерархия подкаталогов до трёх уровней.
Например, при такой конфигурации
</p> <blockquote class="example"><pre>
client_body_temp_path /spool/nginx/client_temp 1 2;
</pre></blockquote><p> 
путь к временному файлу будет следующего вида:
</p> <blockquote class="example"><pre>
/spool/nginx/client_temp/7/45/00000123457
</pre></blockquote><p> 
</p><a name="client_body_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>client_body_timeout</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>client_body_timeout 60s;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт таймаут при чтении тела запроса клиента.
Таймаут устанавливается не на всю передачу тела запроса,
а только между двумя последовательными операциями чтения.
Если по истечении этого времени клиент ничего не передаст,
обработка запроса прекращается с ошибкой
408 (Request Time-out).
</p><a name="client_header_buffer_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>client_header_buffer_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>client_header_buffer_size 1k;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт размер буфера для чтения заголовка запроса клиента.
Для большинства запросов достаточно буфера размером в 1K байт.
Однако если в запросе есть длинные cookies, или же запрос
пришёл от WAP-клиента, то он может не поместиться в 1K.
Поэтому, если строка запроса или поле заголовка запроса
не помещаются полностью в этот буфер, то выделяются буферы
большего размера, задаваемые директивой
<a href="#large_client_header_buffers">large_client_header_buffers</a>.
</p><p>
Если директива указана на уровне <a href="#server">server</a>,
то может использоваться значение из сервера по умолчанию.
Подробнее см. в разделе
“<a href="server_names.html#virtual_server_selection">Выбор
виртуального сервера</a>”.
</p><a name="client_header_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>client_header_timeout</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>client_header_timeout 60s;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт таймаут при чтении заголовка запроса клиента.
Если по истечении этого времени клиент не передаст полностью заголовок,
обработка запроса прекращается с ошибкой
408 (Request Time-out).
</p><a name="client_max_body_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>client_max_body_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>client_max_body_size 1m;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт максимально допустимый размер тела запроса клиента.
Если размер больше заданного, то клиенту возвращается ошибка
413 (Request Entity Too Large).
Следует иметь в виду, что
браузеры не умеют корректно показывать
эту ошибку.
Установка параметра <code><i>размер</i></code> в 0 отключает
проверку размера тела запроса клиента.
</p><a name="connection_pool_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>connection_pool_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>connection_pool_size 256|512;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Позволяет производить точную настройку выделения памяти
под конкретные соединения.
Эта директива не оказывает существенного влияния на
производительность, и её не следует использовать.
По умолчанию размер равен
256 байт на 32-битных платформах и 512 байт на 64-битных платформах.
</p> <blockquote class="note">
До версии 1.9.8 по умолчанию использовалось значение 256 на всех платформах.
</blockquote><p> 
</p><a name="default_type"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>default_type</strong> <code><i>mime-тип</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>default_type text/plain;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт MIME-тип ответов по умолчанию.
Соответствие расширений имён файлов MIME-типу ответов задаётся
с помощью директивы <a href="#types">types</a>.
</p><a name="directio"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>directio</strong> <code><i>размер</i></code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>directio off;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 0.7.7.
            </p></div><p>
Разрешает использовать флаги
<code>O_DIRECT</code> (FreeBSD, Linux),
<code>F_NOCACHE</code> (macOS)
или функцию <code>directio()</code> (Solaris)
при чтении файлов, размер которых больше либо равен указанному.
Директива автоматически запрещает (0.7.15) использование
<a href="#sendfile">sendfile</a>
для данного запроса.
Рекомендуется использовать для больших файлов:
</p> <blockquote class="example"><pre>
directio 4m;
</pre></blockquote><p> 
или при использовании <a href="#aio">aio</a> в Linux.
</p><a name="directio_alignment"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>directio_alignment</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>directio_alignment 512;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 0.8.11.
            </p></div><p>
Устанавливает выравнивание для
<a href="#directio">directio</a>.
В большинстве случаев достаточно 512-байтового выравнивания, однако
при использовании XFS под Linux его нужно увеличить до 4K.
</p><a name="disable_symlinks"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>disable_symlinks</strong> <code>off</code>;</code><br><code><strong>disable_symlinks</strong> 
    <code>on</code> |
    <code>if_not_owner</code>
    [<code>from</code>=<code><i>часть</i></code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>disable_symlinks off;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.1.15.
            </p></div><p>
Определяет, как следует поступать с символическими ссылками
при открытии файлов:
</p> <dl class="compact">

<dt><code>off</code></dt>
<dd>
Символические ссылки в пути допускаются и не проверяются.
Это стандартное поведение.
</dd>

<dt><code>on</code></dt>
<dd>
Если любой компонент пути является символической ссылкой,
доступ к файлу запрещается.
</dd>

<dt><code>if_not_owner</code></dt>
<dd>
Доступ к файлу запрещается, если любой компонент пути
является символической ссылкой, а ссылка и объект, на
который она ссылается, имеют разных владельцев.
</dd>

<dt><code>from</code>=<code><i>часть</i></code></dt>
<dd>
При проверке символических ссылок
(параметры <code>on</code> и <code>if_not_owner</code>)
обычно проверяются все компоненты пути.
Можно не проверять символические ссылки в начальной части пути,
указав дополнительно параметр
<code>from</code>=<code><i>часть</i></code>.
В этом случае символические ссылки проверяются лишь начиная
с компонента пути, который следует за заданной начальной частью.
Если значение не является начальной частью проверяемого пути,
путь проверяется целиком, как если бы этот параметр не был указан вовсе.
Если значение целиком совпадает с именем файла,
символические ссылки не проверяются.
В значении параметра можно использовать переменные.
</dd>

</dl><p> 
</p><p>
Пример:
</p> <blockquote class="example"><pre>
disable_symlinks on from=$document_root;
</pre></blockquote><p> 
</p><p>
Эта директива доступна только на системах, в которых есть
интерфейсы <code>openat()</code> и <code>fstatat()</code>.
К таким системам относятся современные версии FreeBSD, Linux и Solaris.
</p><p>
Параметры <code>on</code> и <code>if_not_owner</code>
требуют дополнительных затрат на обработку.
</p> <blockquote class="note">
На системах, не поддерживающих операцию открытия каталогов только для поиска,
для использования этих параметров требуется, чтобы рабочие процессы
имели право читать все проверяемые каталоги.
</blockquote><p> 
</p><p>
</p> <blockquote class="note">
Модули
<a href="ngx_http_autoindex_module.html">ngx_http_autoindex_module</a>,
<a href="ngx_http_random_index_module.html">ngx_http_random_index_module</a>
и <a href="ngx_http_dav_module.html">ngx_http_dav_module</a>
в настоящий момент игнорируют эту директиву.
</blockquote><p> 
</p><a name="error_page"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>error_page</strong> 
    <code><i>код</i></code> ...
    [<code>=</code>[<code><i>ответ</i></code>]]
    <code><i>uri</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code>, <code>if в location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт URI, который будет показываться для указанных ошибок.
В значении <code><i>uri</i></code> можно использовать переменные.
</p><p>
Пример:
</p> <blockquote class="example"><pre>
error_page 404             /404.html;
error_page 500 502 503 504 /50x.html;
</pre></blockquote><p> 
</p><p>
При этом делается внутреннее перенаправление на указанный <code><i>uri</i></code>,
а метод запроса клиента меняется на “<code>GET</code>”
(для всех методов, отличных от
“<code>GET</code>” и “<code>HEAD</code>”).
</p><p>
Кроме того, можно поменять код ответа на другой,
используя синтаксис вида “<code>=</code><code><i>ответ</i></code>”, например:
</p> <blockquote class="example"><pre>
error_page 404 =200 /empty.gif;
</pre></blockquote><p> 
</p><p>
Если ошибочный ответ обрабатывается проксированным сервером или
FastCGI/uwsgi/SCGI/gRPC-сервером,
и этот сервер может вернуть разные коды ответов,
например, 200, 302, 401 или 404, то можно выдавать возвращаемый им код:
</p> <blockquote class="example"><pre>
error_page 404 = /404.php;
</pre></blockquote><p> 
</p><p>
Если при внутреннем перенаправлении не нужно менять URI и метод,
то можно передать обработку ошибки в именованный location:
</p> <blockquote class="example"><pre>
location / {
    error_page 404 = @fallback;
}

location @fallback {
    proxy_pass http://backend;
}
</pre></blockquote><p> 
</p><p>
</p> <blockquote class="note">
Если при обработке <code><i>uri</i></code> происходит ошибка,
клиенту возвращается ответ с кодом последней случившейся ошибки.
</blockquote><p> 
</p><p>
Также существует возможность использовать перенаправления URL для обработки
ошибок:
</p> <blockquote class="example"><pre>
error_page 403      http://example.com/forbidden.html;
error_page 404 =301 http://example.com/notfound.html;
</pre></blockquote><p> 
В этом случае по умолчанию клиенту возвращается код ответа 302.
Его можно изменить только на один из кодов ответа, относящихся к
перенаправлениям (301, 302, 303, 307 и 308).
</p> <blockquote class="note">
До версий 1.1.16 и 1.0.13 код 307 не обрабатывался как перенаправление.
</blockquote><p> 

</p> <blockquote class="note">
До версии 1.13.0 код 308 не обрабатывался как перенаправление.
</blockquote><p> 
</p><p>
Директивы наследуются с предыдущего уровня конфигурации при условии, что
на данном уровне не описаны свои директивы <code>error_page</code>.
</p><a name="etag"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>etag</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>etag on;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.3.3.
            </p></div><p>
Разрешает или запрещает автоматическую генерацию поля “ETag”
заголовка ответа для статических ресурсов.
</p><a name="http"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>http</strong> { ... }</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>main</code><br>
                </td>
                </tr>
            </table></div><p>
Предоставляет контекст конфигурационного файла, в котором указываются
директивы HTTP-сервера.
</p><a name="if_modified_since"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>if_modified_since</strong> 
    <code>off</code> |
    <code>exact</code> |
    <code>before</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>if_modified_since exact;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 0.7.24.
            </p></div><p>
Определяет, как сравнивать время модификации ответа с
временем в поле
“If-Modified-Since”
заголовка запроса:

</p> <dl class="compact">

<dt><code>off</code></dt>
<dd>
ответ всегда считается изменившимся (0.7.34);
</dd>

<dt><code>exact</code></dt>
<dd>
точное совпадение;
</dd>

<dt><code>before</code></dt>
<dd>
время модификации ответа меньше или равно времени, заданному в поле
“If-Modified-Since” заголовка запроса.
</dd>

</dl><p> 
</p><a name="ignore_invalid_headers"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>ignore_invalid_headers</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>ignore_invalid_headers on;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Если включено, nginx игнорирует поля заголовка с недопустимыми именами.
Допустимыми считаются имена, состоящие из английских букв, цифр, дефисов
и возможно знаков подчёркивания (последнее контролируется директивой
<a href="#underscores_in_headers">underscores_in_headers</a>).
</p><p>
Если директива указана на уровне <a href="#server">server</a>,
то может использоваться значение из сервера по умолчанию.
Подробнее см. в разделе
“<a href="server_names.html#virtual_server_selection">Выбор
виртуального сервера</a>”.
</p><a name="internal"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>internal</strong>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Указывает, что location может использоваться только для внутренних запросов.
Для внешних запросов клиенту будет возвращаться ошибка
404 (Not Found).
Внутренними запросами являются:

</p> <ul class="compact">

<li>
запросы, перенаправленные директивами
<a href="#error_page">error_page</a>,
<a href="ngx_http_index_module.html#index">index</a>,
<a href="ngx_http_internal_redirect_module.html#internal_redirect">internal_redirect</a>,
<a href="ngx_http_random_index_module.html#random_index">random_index</a> и
<a href="#try_files">try_files</a>;
</li>

<li>
запросы, перенаправленные с помощью поля
“X-Accel-Redirect” заголовка ответа вышестоящего сервера;
</li>

<li>
подзапросы, формируемые командой
“<code>include virtual</code>”
модуля
<a href="ngx_http_ssi_module.html">ngx_http_ssi_module</a>,
директивами модуля
<a href="ngx_http_addition_module.html">ngx_http_addition_module</a>,
а также директивами
<a href="ngx_http_auth_request_module.html#auth_request">auth_request</a> и
<a href="ngx_http_mirror_module.html#mirror">mirror</a>;

</li>

<li>
запросы, изменённые директивой
<a href="ngx_http_rewrite_module.html#rewrite">rewrite</a>.
</li>

</ul><p> 
</p><p>
Пример:
</p> <blockquote class="example"><pre>
error_page 404 /404.html;

location = /404.html {
    internal;
}
</pre></blockquote><p> 
</p> <blockquote class="note">
Для предотвращения зацикливания, которое может возникнуть при
использовании некорректных конфигураций, количество внутренних
перенаправлений ограничено десятью.
По достижении этого ограничения будет возвращена ошибка
500 (Internal Server Error).
В таком случае в лог-файле ошибок можно увидеть сообщение
“rewrite or internal redirection cycle”.
</blockquote><p> 
</p><a name="keepalive_disable"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>keepalive_disable</strong> <code>none</code> | <code><i>браузер</i></code> ...;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>keepalive_disable msie6;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Запрещает keep-alive соединения с некорректно ведущими себя браузерами.
Параметры <code><i>браузер</i></code> указывают, на какие браузеры это
распространяется.
Значение <code>msie6</code> запрещает keep-alive соединения
со старыми версиями MSIE после получения запроса POST.
Значение <code>safari</code> запрещает keep-alive соединения
с Safari и подобными им браузерами на macOS и подобных ей ОС.
Значение <code>none</code> разрешает keep-alive соединения
со всеми браузерами.
</p> <blockquote class="note">
До версии 1.1.18 под значение <code>safari</code> подпадали
все Safari и подобные им браузеры на всех ОС, и keep-alive
соединения с ними были по умолчанию запрещены.
</blockquote><p> 
</p><a name="keepalive_requests"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>keepalive_requests</strong> <code><i>число</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>keepalive_requests 1000;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 0.8.0.
            </p></div><p>
Задаёт максимальное число запросов, которые можно
сделать по одному keep-alive соединению.
После того, как сделано максимальное число запросов,
соединение закрывается.
</p><p>
Периодическое закрытие соединений необходимо для освобождения
памяти, выделенной под конкретные соединения.
Поэтому использование слишком большого максимального числа запросов
может приводить к чрезмерному потреблению памяти и не рекомендуется.
</p><p>
</p> <blockquote class="note">
До версии 1.19.10 по умолчанию использовалось значение 100.
</blockquote><p> 
</p><a name="keepalive_time"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>keepalive_time</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>keepalive_time 1h;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.19.10.
            </p></div><p>
Ограничивает максимальное время, в течение которого
могут обрабатываться запросы в рамках keep-alive соединения.
По достижении заданного времени соединение закрывается
после обработки очередного запроса.
</p><a name="keepalive_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>keepalive_timeout</strong> 
    <code><i>таймаут</i></code>
    [<code><i>заголовок_таймаута</i></code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>keepalive_timeout 75s;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Первый параметр задаёт таймаут, в течение которого keep-alive
соединение с клиентом не будет закрыто со стороны сервера.
Значение 0 запрещает keep-alive соединения с клиентами.
Второй необязательный параметр задаёт значение в поле
“Keep-Alive: timeout=<code><i>время</i></code>”
заголовка ответа.
Два параметра могут отличаться друг от друга.
</p><p>
Поле
“Keep-Alive: timeout=<code><i>время</i></code>”
заголовка понимают Mozilla и Konqueror.
MSIE сам закрывает keep-alive соединение примерно через 60 секунд.
</p><a name="large_client_header_buffers"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>large_client_header_buffers</strong> <code><i>число</i></code> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>large_client_header_buffers 4 8k;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт максимальное <code><i>число</i></code> и <code><i>размер</i></code>
буферов для чтения большого заголовка запроса клиента.
Строка запроса не должна превышать размера одного буфера, иначе клиенту
возвращается ошибка
414 (Request-URI Too Large).
Поле заголовка запроса также не должно превышать размера одного буфера,
иначе клиенту возвращается ошибка
400 (Bad Request).
Буферы выделяются только по мере необходимости.
По умолчанию размер одного буфера равен 8K байт.
Если по окончании обработки запроса соединение переходит в состояние
keep-alive, эти буферы освобождаются.
</p><p>
Если директива указана на уровне <a href="#server">server</a>,
то может использоваться значение из сервера по умолчанию.
Подробнее см. в разделе
“<a href="server_names.html#virtual_server_selection">Выбор
виртуального сервера</a>”.
</p><a name="limit_except"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>limit_except</strong> <code><i>метод</i></code> ... { ... }</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Ограничивает HTTP-методы, доступные внутри location.
Параметр <code><i>метод</i></code> может быть одним из
<code>GET</code>,
<code>HEAD</code>,
<code>POST</code>,
<code>PUT</code>,
<code>DELETE</code>,
<code>MKCOL</code>,
<code>COPY</code>,
<code>MOVE</code>,
<code>OPTIONS</code>,
<code>PROPFIND</code>,
<code>PROPPATCH</code>,
<code>LOCK</code>,
<code>UNLOCK</code>
или
<code>PATCH</code>.
Если разрешён метод <code>GET</code>, то метод
<code>HEAD</code> также будет разрешён.
Доступ к остальным методам может быть ограничен при помощи директив модулей
<a href="ngx_http_access_module.html">ngx_http_access_module</a>,
<a href="ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a>
и
<a href="ngx_http_auth_jwt_module.html">ngx_http_auth_jwt_module</a>
(1.13.10):
</p> <blockquote class="example"><pre>
limit_except GET {
    allow 192.168.1.0/32;
    deny  all;
}
</pre></blockquote><p> 
Обратите внимание, что данное ограничение действует для всех методов,
<strong>кроме</strong> GET и HEAD.
</p><a name="limit_rate"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>limit_rate</strong> <code><i>скорость</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>limit_rate 0;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code>, <code>if в location</code><br>
                </td>
                </tr>
            </table></div><p>
Ограничивает скорость передачи ответа клиенту.
<code><i>Скорость</i></code> задаётся в байтах в секунду.
Значение 0 отключает ограничение скорости.

Ограничение устанавливается на запрос, поэтому, если клиент одновременно
откроет два соединения, суммарная скорость будет вдвое выше
заданного ограничения.
</p><p>
В значении параметра можно использовать переменные (1.17.0).
Это может быть полезно в случаях, когда скорость нужно ограничивать
в зависимости от какого-либо условия:
</p> <blockquote class="example"><pre>
map $slow $rate {
    1     4k;
    2     8k;
}

limit_rate $rate;
</pre></blockquote><p> 
</p><p>
Ограничение скорости можно также задать в переменной
<a href="#var_limit_rate"><code>$limit_rate</code></a>,
однако начиная с 1.17.0 использовать данный метод не рекомендуется:
</p> <blockquote class="example"><pre>
server {

    if ($slow) {
        set $limit_rate 4k;
    }

    ...
}
</pre></blockquote><p> 
</p><p>
Кроме того, ограничение скорости может быть задано в поле
“X-Accel-Limit-Rate” заголовка ответа проксированного сервера.
Эту возможность можно запретить с помощью директив
<a href="ngx_http_proxy_module.html#proxy_ignore_headers">proxy_ignore_headers</a>,
<a href="ngx_http_fastcgi_module.html#fastcgi_ignore_headers">fastcgi_ignore_headers</a>,
<a href="ngx_http_uwsgi_module.html#uwsgi_ignore_headers">uwsgi_ignore_headers</a>
и
<a href="ngx_http_scgi_module.html#scgi_ignore_headers">scgi_ignore_headers</a>.
</p><a name="limit_rate_after"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>limit_rate_after</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>limit_rate_after 0;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code>, <code>if в location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 0.8.0.
            </p></div><p>
Задаёт начальный объём данных, после передачи которого начинает
ограничиваться скорость передачи ответа клиенту.
В значении параметра можно использовать переменные (1.17.0).
</p><p>
Пример:
</p> <blockquote class="example"><pre>
location /flv/ {
    flv;
    limit_rate_after 500k;
    limit_rate       50k;
}
</pre></blockquote><p> 
</p><a name="lingering_close"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>lingering_close</strong> 
    <code>off</code> |
    <code>on</code> |
    <code>always</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>lingering_close on;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table>
                        <p>
                    Эта директива появилась в версиях 1.1.0 и 1.0.6.
                    
                        </p>
                    </div><p>
Управляет закрытием соединений с клиентами.
</p><p>
Со значением по умолчанию “<code>on</code>” nginx будет
<a href="#lingering_timeout">ждать</a> и
<a href="#lingering_time">обрабатывать</a> дополнительные данные,
поступающие от клиента, перед полным закрытием соединения, но только
если эвристика указывает на то, что клиент может ещё послать данные.
</p><p>
Со значением “<code>always</code>” nginx всегда будет
ждать и обрабатывать дополнительные данные, поступающие от клиента.
</p><p>
Со значением “<code>off</code>” nginx не будет ждать поступления
дополнительных данных и сразу же закроет соединение.
Это поведение нарушает протокол и поэтому не должно использоваться без
необходимости.
</p><p>
Для управления закрытием
<a href="ngx_http_v2_module.html">HTTP/2</a>-соединений
директива должна быть задана на уровне <a href="#server">server</a> (1.19.1).
</p><a name="lingering_time"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>lingering_time</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>lingering_time 30s;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Если действует <a href="#lingering_close">lingering_close</a>,
эта директива задаёт максимальное время, в течение которого nginx
будет обрабатывать (читать и игнорировать) дополнительные данные,
поступающие от клиента.
По прошествии этого времени соединение будет закрыто, даже если
будут ещё данные.
</p><a name="lingering_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>lingering_timeout</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>lingering_timeout 5s;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Если действует <a href="#lingering_close">lingering_close</a>, эта директива задаёт
максимальное время ожидания поступления дополнительных данных от клиента.
Если в течение этого времени данные не были получены, соединение закрывается.
В противном случае данные читаются и игнорируются, и nginx снова
ждёт поступления данных.
Цикл “ждать-читать-игнорировать” повторяется, но не дольше чем задано
директивой <a href="#lingering_time">lingering_time</a>.
</p><a name="listen"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>listen</strong> 
    <code><i>адрес</i></code>[:<code><i>порт</i></code>]
    [<code>default_server</code>]
    [<code>ssl</code>]
    [<code>http2</code> |
     <code>quic</code>]
    [<code>proxy_protocol</code>]
    [<code>setfib</code>=<code><i>число</i></code>]
    [<code>fastopen</code>=<code><i>число</i></code>]
    [<code>backlog</code>=<code><i>число</i></code>]
    [<code>rcvbuf</code>=<code><i>размер</i></code>]
    [<code>sndbuf</code>=<code><i>размер</i></code>]
    [<code>accept_filter</code>=<code><i>фильтр</i></code>]
    [<code>deferred</code>]
    [<code>bind</code>]
    [<code>ipv6only</code>=<code>on</code>|<code>off</code>]
    [<code>reuseport</code>]
    [<code>so_keepalive</code>=<code>on</code>|<code>off</code>|[<code><i>keepidle</i></code>]:[<code><i>keepintvl</i></code>]:[<code><i>keepcnt</i></code>]];</code><br><code><strong>listen</strong> 
    <code><i>порт</i></code>
    [<code>default_server</code>]
    [<code>ssl</code>]
    [<code>http2</code> |
     <code>quic</code>]
    [<code>proxy_protocol</code>]
    [<code>setfib</code>=<code><i>число</i></code>]
    [<code>fastopen</code>=<code><i>число</i></code>]
    [<code>backlog</code>=<code><i>число</i></code>]
    [<code>rcvbuf</code>=<code><i>размер</i></code>]
    [<code>sndbuf</code>=<code><i>размер</i></code>]
    [<code>accept_filter</code>=<code><i>фильтр</i></code>]
    [<code>deferred</code>]
    [<code>bind</code>]
    [<code>ipv6only</code>=<code>on</code>|<code>off</code>]
    [<code>reuseport</code>]
    [<code>so_keepalive</code>=<code>on</code>|<code>off</code>|[<code><i>keepidle</i></code>]:[<code><i>keepintvl</i></code>]:[<code><i>keepcnt</i></code>]];</code><br><code><strong>listen</strong> 
    <code>unix:</code><code><i>путь</i></code>
    [<code>default_server</code>]
    [<code>ssl</code>]
    [<code>http2</code> |
     <code>quic</code>]
    [<code>proxy_protocol</code>]
    [<code>backlog</code>=<code><i>число</i></code>]
    [<code>rcvbuf</code>=<code><i>размер</i></code>]
    [<code>sndbuf</code>=<code><i>размер</i></code>]
    [<code>accept_filter</code>=<code><i>фильтр</i></code>]
    [<code>deferred</code>]
    [<code>bind</code>]
    [<code>so_keepalive</code>=<code>on</code>|<code>off</code>|[<code><i>keepidle</i></code>]:[<code><i>keepintvl</i></code>]:[<code><i>keepcnt</i></code>]];</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>listen *:80 | *:8000;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт <code><i>адрес</i></code> и <code><i>порт</i></code> для IP
или <code><i>путь</i></code> для UNIX-сокета,
на которых сервер будет принимать запросы.
Можно указать <code><i>адрес</i></code> и <code><i>порт</i></code>,
либо только <code><i>адрес</i></code> или только <code><i>порт</i></code>.
Кроме того, <code><i>адрес</i></code> может быть именем хоста, например:
</p> <blockquote class="example"><pre>
listen 127.0.0.1:8000;
listen 127.0.0.1;
listen 8000;
listen *:8000;
listen localhost:8000;
</pre></blockquote><p> 
IPv6-адреса (0.7.36) задаются в квадратных скобках:
</p> <blockquote class="example"><pre>
listen [::]:8000;
listen [::1];
</pre></blockquote><p> 
UNIX-сокеты (0.8.21) задаются при помощи префикса “<code>unix:</code>”:
</p> <blockquote class="example"><pre>
listen unix:/var/run/nginx.sock;
</pre></blockquote><p> 
</p><p>
Если указан только <code><i>адрес</i></code>, то используется порт 80.
</p><p>
Если директива не указана, то используется либо <code>*:80</code>,
если nginx работает с привилегиями суперпользователя,
либо <code>*:8000</code>.
</p><p>
Если у директивы есть параметр <code>default_server</code>, то сервер,
в котором описана эта директива, будет сервером по умолчанию для указанной пары
<code><i>адрес</i></code>:<code><i>порт</i></code>.
Если же директив с параметром <code>default_server</code> нет, то
сервером по умолчанию будет первый сервер, в котором описана пара
<code><i>адрес</i></code>:<code><i>порт</i></code>.
</p> <blockquote class="note">
До версии 0.8.21 этот параметр назывался просто
<code>default</code>.
</blockquote><p> 
</p><p>
Параметр <code>ssl</code> (0.7.14) указывает на то, что все соединения,
принимаемые на данном порту, должны работать в режиме SSL.
Это позволяет задать компактную <a href="configuring_https_servers.html#single_http_https_server">конфигурацию</a> для сервера,
работающего сразу в двух режимах — HTTP и HTTPS.
</p><p>
Параметр <code>http2</code> (1.9.5) позволяет принимать на этом порту
<a href="ngx_http_v2_module.html">HTTP/2</a>-соединения.
Обычно, чтобы это работало, следует также указать параметр
<code>ssl</code>, однако nginx можно также настроить и на приём
HTTP/2-соединений без SSL.
</p> <blockquote class="note">
Параметр устарел, вместо него следует использовать
директиву <a href="ngx_http_v2_module.html#http2">http2</a>.
</blockquote><p> 
</p><a name="quic"></a><p>
Параметр <code>quic</code> (1.25.0) позволяет принимать на этом порту
<a href="ngx_http_v3_module.html">QUIC</a>-соединения.
</p><p>
Параметр <code>proxy_protocol</code> (1.5.12)
указывает на то, что все соединения, принимаемые на данном порту,
должны использовать
<a href="http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt">протокол
PROXY</a>.
</p> <blockquote class="note">
Протокол PROXY версии 2 поддерживается начиная с версии 1.13.11.
</blockquote><p> 
</p><p>
В директиве <code>listen</code> можно также указать несколько
дополнительных параметров, специфичных для связанных с сокетами
системных вызовов.
Эти параметры можно задать в любой директиве <code>listen</code>,
но только один раз для указанной пары
<code><i>адрес</i></code>:<code><i>порт</i></code>.
</p> <blockquote class="note">
До версии 0.8.21 их можно было указывать лишь в директиве
<code>listen</code> совместно с параметром <code>default</code>.
</blockquote><p> 
</p> <dl class="compact">

<dt>
<code>setfib</code>=<code><i>число</i></code>
</dt>
<dd>
этот параметр (0.8.44) задаёт таблицу маршрутизации, FIB
(параметр <code>SO_SETFIB</code>) для слушающего сокета.
В настоящий момент это работает только на FreeBSD.
</dd>

<dt>
<code>fastopen</code>=<code><i>число</i></code>
</dt>
<dd>
включает
“<a href="http://en.wikipedia.org/wiki/TCP_Fast_Open">TCP Fast Open</a>”
для слушающего сокета (1.5.8) и
<a href="https://datatracker.ietf.org/doc/html/rfc7413#section-5.1">ограничивает</a>
максимальную длину очереди соединений, которые ещё не завершили процесс
three-way handshake.
<blockquote class="note">
Не включайте “TCP Fast Open”, не убедившись, что сервер может адекватно
обрабатывать многократное получение
<a href="https://datatracker.ietf.org/doc/html/rfc7413#section-6.1">
одного и того же SYN-пакета с данными</a>.
</blockquote>
</dd>

<dt>
<code>backlog</code>=<code><i>число</i></code>
</dt>
<dd>
задаёт параметр <code>backlog</code> в вызове
<code>listen()</code>, который ограничивает
максимальный размер очереди ожидающих приёма соединений.
По умолчанию <code>backlog</code> устанавливается равным -1 для
FreeBSD, DragonFly BSD и macOS, и 511 для других платформ.
</dd>

<dt>
<code>rcvbuf</code>=<code><i>размер</i></code>
</dt>
<dd>
задаёт размер буфера приёма
(параметр <code>SO_RCVBUF</code>) для слушающего сокета.
</dd>

<dt>
<code>sndbuf</code>=<code><i>размер</i></code>
</dt>
<dd>
задаёт размер буфера передачи
(параметр <code>SO_SNDBUF</code>) для слушающего сокета.
</dd>

<dt>
<code>accept_filter</code>=<code><i>фильтр</i></code>
</dt>
<dd>
задаёт название accept-фильтра
(параметр <code>SO_ACCEPTFILTER</code>) для слушающего сокета,
который включается для фильтрации входящих соединений
перед передачей их в <code>accept()</code>.
Работает только на FreeBSD и NetBSD 5.0+.
Можно использовать два фильтра:
<a href="http://man.freebsd.org/accf_data">dataready</a>
и
<a href="http://man.freebsd.org/accf_http">httpready</a>.
</dd>

<dt>
<code>deferred</code>
</dt>
<dd>
указывает использовать отложенный <code>accept()</code>
(параметр <code>TCP_DEFER_ACCEPT</code> сокета) на Linux.
</dd>

<dt>
<code>bind</code>
</dt>
<dd>
указывает, что для данной пары
<code><i>адрес</i></code>:<code><i>порт</i></code> нужно делать
<code>bind()</code> отдельно.
Это нужно потому, что если описаны несколько директив <code>listen</code>
с одинаковым портом, но разными адресами, и одна из директив
<code>listen</code> слушает на всех адресах для данного порта
(<code>*:</code><code><i>порт</i></code>), то nginx сделает
<code>bind()</code> только на <code>*:</code><code><i>порт</i></code>.
Необходимо заметить, что в этом случае для определения адреса, на который
пришло соединение, делается системный вызов <code>getsockname()</code>.
Если же используются параметры <code>setfib</code>,
<code>fastopen</code>,
<code>backlog</code>, <code>rcvbuf</code>,
<code>sndbuf</code>, <code>accept_filter</code>,
<code>deferred</code>, <code>ipv6only</code>,
<code>reuseport</code>
или <code>so_keepalive</code>,
то для данной пары
<code><i>адрес</i></code>:<code><i>порт</i></code> всегда делается
отдельный вызов <code>bind()</code>.
</dd>

<dt>
<code>ipv6only</code>=<code>on</code>|<code>off</code>
</dt>
<dd>
этот параметр (0.7.42) определяет
(через параметр сокета <code>IPV6_V6ONLY</code>),
будет ли слушающий на wildcard-адресе <code>[::]</code> IPv6-сокет
принимать только IPv6-соединения, или же одновременно IPv6- и IPv4-соединения.
По умолчанию параметр включён.
Установить его можно только один раз на старте.
<blockquote class="note">
До версии 1.3.4,
если этот параметр не был задан явно, то для сокета действовали
настройки операционной системы.
</blockquote>
</dd>

<dt id="reuseport">
<code>reuseport</code>
</dt>
<dd>
этот параметр (1.9.1) указывает, что нужно создавать отдельный слушающий сокет
для каждого рабочего процесса
(через параметр сокета
<code>SO_REUSEPORT</code> для Linux 3.9+ и DragonFly BSD
или <code>SO_REUSEPORT_LB</code> для FreeBSD 12+), позволяя ядру
распределять входящие соединения между рабочими процессами.
В настоящий момент это работает только на Linux 3.9+, DragonFly BSD
и FreeBSD 12+ (1.15.1).
<blockquote class="note">
Ненадлежащее использование параметра может быть
<a href="http://man7.org/linux/man-pages/man7/socket.7.html">небезопасно</a>.
</blockquote>
</dd>

<dt>
<code>so_keepalive</code>=<code>on</code>|<code>off</code>|[<code><i>keepidle</i></code>]:[<code><i>keepintvl</i></code>]:[<code><i>keepcnt</i></code>]
</dt>
<dd>
этот параметр (1.1.11) конфигурирует для слушающего сокета
поведение “TCP keepalive”.
Если этот параметр опущен, то для сокета будут действовать
настройки операционной системы.
Если он установлен в значение “<code>on</code>”, то для сокета
включается параметр <code>SO_KEEPALIVE</code>.
Если он установлен в значение “<code>off</code>”, то для сокета
параметр <code>SO_KEEPALIVE</code> выключается.
Некоторые операционные системы поддерживают настройку параметров
“TCP keepalive” на уровне сокета посредством параметров
<code>TCP_KEEPIDLE</code>, <code>TCP_KEEPINTVL</code> и
<code>TCP_KEEPCNT</code>.
На таких системах (в настоящий момент это Linux 2.4+, NetBSD 5+ и
FreeBSD 9.0-STABLE)
их можно сконфигурировать с помощью параметров <code><i>keepidle</i></code>,
<code><i>keepintvl</i></code> и <code><i>keepcnt</i></code>.
Один или два параметра могут быть опущены, в таком случае для
соответствующего параметра сокета будут действовать стандартные
системные настройки.
Например,
<blockquote class="example"><pre>so_keepalive=30m::10</pre></blockquote>
установит таймаут бездействия (<code>TCP_KEEPIDLE</code>) в 30 минут,
для интервала проб (<code>TCP_KEEPINTVL</code>) будет действовать
стандартная системная настройка, а счётчик проб (<code>TCP_KEEPCNT</code>)
будет равен 10.
</dd>

</dl><p> 
</p><p>
Пример:
</p> <blockquote class="example"><pre>
listen 127.0.0.1 default_server accept_filter=dataready backlog=1024;
</pre></blockquote><p> 
</p><a name="location"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>location</strong> [
    <code>=</code> |
    <code>~</code> |
    <code>~*</code> |
    <code>^~</code>
    ] <code><i>uri</i></code> { ... }</code><br><code><strong>location</strong> <code>@</code><code><i>имя</i></code> { ... }</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Устанавливает конфигурацию в зависимости от URI запроса.
</p><p>
Для сопоставления используется URI запроса в нормализованном виде,
после декодирования текста, заданного в виде “<code>%XX</code>”,
преобразования относительных элементов пути “<code>.</code>” и
“<code>..</code>” в реальные и возможной
<a href="#merge_slashes">замены</a> двух и более подряд идущих
слэшей на один.
</p><p>
location можно задать префиксной строкой или регулярным выражением.
Регулярные выражения задаются либо с модификатором “<code>~*</code>”
(для поиска совпадения без учёта регистра символов),
либо с модификатором “<code>~</code>” (с учётом регистра).
Чтобы найти location, соответствующий запросу, вначале проверяются
location’ы, заданные префиксными строками (префиксные location’ы).
Среди них ищется location с совпадающим префиксом
максимальной длины и запоминается.
Затем проверяются регулярные выражения, в порядке их следования
в конфигурационном файле.
Проверка регулярных выражений прекращается после первого же совпадения,
и используется соответствующая конфигурация.
Если совпадение с регулярным выражением не найдено, то используется
конфигурация запомненного ранее префиксного location’а.
</p><p>
Блоки <code>location</code> могут быть вложенными,
с некоторыми исключениями, о которых говорится ниже.
</p><p>
Для операционных систем, нечувствительных к регистру символов, таких
как macOS и Cygwin, сравнение с префиксными строками производится
без учёта регистра (0.7.7).
Однако сравнение ограничено только однобайтными locale’ями.
</p><p>
Регулярные выражения могут содержать выделения (0.7.40), которые могут
затем использоваться в других директивах.
</p><p>
Если у совпавшего префиксного location’а максимальной длины указан модификатор
“<code>^~</code>”, то регулярные выражения не проверяются.
</p><p>
Кроме того, с помощью модификатора “<code>=</code>” можно задать точное
совпадение URI и location.
При точном совпадении поиск сразу же прекращается.
Например, если запрос “<code>/</code>” случается часто, то
указав “<code>location = /</code>”, можно ускорить обработку
этих запросов, так как поиск прекратится после первого же сравнения.
Очевидно, что такой location не может иметь вложенные location’ы.
</p><p>
</p> <blockquote class="note">
В версиях с 0.7.1 по 0.8.41, если запрос точно совпал с префиксным
location’ом без модификаторов “<code>=</code>” и “<code>^~</code>”,
то поиск тоже сразу же прекращается и регулярные выражения также
не проверяются.
</blockquote><p> 
</p><p>
Проиллюстрируем вышесказанное примером:
</p> <blockquote class="example"><pre>
location = / {
    [ конфигурация А ]
}

location / {
    [ конфигурация Б ]
}

location /documents/ {
    [ конфигурация В ]
}

location ^~ /images/ {
    [ конфигурация Г ]
}

location ~* \.(gif|jpg|jpeg)$ {
    [ конфигурация Д ]
}
</pre></blockquote><p> 
Для запроса “<code>/</code>” будет выбрана конфигурация А,
для запроса “<code>/index.html</code>” — конфигурация Б,
для запроса “<code>/documents/document.html</code>” — конфигурация В,
для запроса “<code>/images/1.gif</code>” — конфигурация Г,
а для запроса “<code>/documents/1.jpg</code>” — конфигурация Д.
</p><a name="location_named"></a><p>
Префикс “<code>@</code>” задаёт именованный location.
Такой location не используется при обычной обработке запросов, а
предназначен только для перенаправления в него запросов.
Такие location’ы не могут быть вложенными и не могут содержать
вложенные location’ы.
</p><p>
Если location задан префиксной строкой со слэшом в конце
и запросы обрабатываются при помощи
<a href="ngx_http_proxy_module.html#proxy_pass">proxy_pass</a>,
<a href="ngx_http_fastcgi_module.html#fastcgi_pass">fastcgi_pass</a>,
<a href="ngx_http_uwsgi_module.html#uwsgi_pass">uwsgi_pass</a>,
<a href="ngx_http_scgi_module.html#scgi_pass">scgi_pass</a>,
<a href="ngx_http_memcached_module.html#memcached_pass">memcached_pass</a> или
<a href="ngx_http_grpc_module.html#grpc_pass">grpc_pass</a>,
происходит специальная обработка.
В ответ на запрос с URI равным этой строке, но без завершающего слэша,
будет возвращено постоянное перенаправление с кодом 301
на URI с добавленным в конец слэшом.
Если такое поведение нежелательно, можно задать точное совпадение
URI и location, например:
</p> <blockquote class="example"><pre>
location /user/ {
    proxy_pass http://user.example.com;
}

location = /user {
    proxy_pass http://login.example.com;
}
</pre></blockquote><p> 
</p><a name="log_not_found"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>log_not_found</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>log_not_found on;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает записывать в
<a href="../ngx_core_module.html#error_log">error_log</a>
ошибки о том, что файл не найден.
</p><a name="log_subrequest"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>log_subrequest</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>log_subrequest off;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает записывать в
<a href="ngx_http_log_module.html#access_log">access_log</a>
подзапросы.
</p><a name="max_ranges"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>max_ranges</strong> <code><i>число</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.1.2.
            </p></div><p>
Ограничивает максимальное допустимое число диапазонов в запросах с
указанием диапазона запрашиваемых байт (byte-range requests).
Запросы, превышающие указанное ограничение, обрабатываются как
если бы они не содержали указания диапазонов.
По умолчанию число диапазонов не ограничено.
Значение 0 полностью запрещает поддержку диапазонов.
</p><a name="merge_slashes"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>merge_slashes</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>merge_slashes on;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает преобразование URI путём замены двух и более подряд
идущих слэшей (“<code>/</code>”) на один.
</p><p>
Необходимо иметь в виду, что это преобразование необходимо для корректной
проверки префиксных строк и регулярных выражений.
Если его не делать, то запрос “<code>//scripts/one.php</code>”
не попадёт в
</p> <blockquote class="example"><pre>
location /scripts/ {
    ...
}
</pre></blockquote><p> 
и может быть обслужен как статический файл.
Поэтому он преобразуется к виду “<code>/scripts/one.php</code>”.
</p><p>
Запрет преобразования может понадобиться, если в URI используются имена,
закодированные методом base64, в котором задействован символ
“<code>/</code>”.
Однако из соображений безопасности лучше избегать отключения преобразования.
</p><p>
Если директива указана на уровне <a href="#server">server</a>,
то может использоваться значение из сервера по умолчанию.
Подробнее см. в разделе
“<a href="server_names.html#virtual_server_selection">Выбор
виртуального сервера</a>”.
</p><a name="msie_padding"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>msie_padding</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>msie_padding on;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает добавлять в ответы для MSIE со статусом больше 400
комментарий для увеличения размера ответа до 512 байт.
</p><a name="msie_refresh"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>msie_refresh</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>msie_refresh off;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает выдавать для MSIE клиентов refresh’ы вместо
перенаправлений.
</p><a name="open_file_cache"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>open_file_cache</strong> <code>off</code>;</code><br><code><strong>open_file_cache</strong> 
<code>max</code>=<code><i>N</i></code>
[<code>inactive</code>=<code><i>время</i></code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>open_file_cache off;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт кэш, в котором могут храниться:
</p> <ul class="compact">

<li>
дескрипторы открытых файлов, информация об их размерах и времени модификации;
</li>

<li>
информация о существовании каталогов;
</li>

<li>
информация об ошибках поиска файла — “нет файла”, “нет прав на чтение”
и тому подобное.
<blockquote class="note">
Кэширование ошибок нужно разрешить отдельно директивой
<a href="#open_file_cache_errors">open_file_cache_errors</a>.
</blockquote>
</li>

</ul><p> 
</p><p>
У директивы есть следующие параметры:
</p> <dl class="compact">

<dt>
<code>max</code>
</dt>
<dd>
задаёт максимальное число элементов в кэше;
при переполнении кэша удаляются наименее востребованные элементы (LRU);
</dd>

<dt>
<code>inactive</code>
</dt>
<dd>
задаёт время, после которого элемент кэша удаляется, если к нему
не было обращений в течение этого времени; по умолчанию 60 секунд;
</dd>

<dt>
<code>off</code>
</dt>
<dd>
запрещает кэш.
</dd>

</dl><p> 
</p><p>
Пример:
</p> <blockquote class="example"><pre>
open_file_cache          max=1000 inactive=20s;
open_file_cache_valid    30s;
open_file_cache_min_uses 2;
open_file_cache_errors   on;

</pre></blockquote><p> 
</p><a name="open_file_cache_errors"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>open_file_cache_errors</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>open_file_cache_errors off;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает кэширование ошибок поиска файлов в
<a href="#open_file_cache">open_file_cache</a>.
</p><a name="open_file_cache_min_uses"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>open_file_cache_min_uses</strong> <code><i>число</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>open_file_cache_min_uses 1;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт минимальное <code><i>число</i></code> обращений к файлу
в течение времени, заданного параметром <code>inactive</code>
директивы <a href="#open_file_cache">open_file_cache</a>, необходимых для того, чтобы дескриптор
файла оставался открытым в кэше.
</p><a name="open_file_cache_valid"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>open_file_cache_valid</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>open_file_cache_valid 60s;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Определяет время, через которое следует проверять актуальность информации
об элементе в
<a href="#open_file_cache">open_file_cache</a>.

</p><a name="output_buffers"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>output_buffers</strong> <code><i>number</i></code> <code><i>size</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>output_buffers 2 32k;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт <code><i>число</i></code> и <code><i>размер</i></code> буферов,
используемых при чтении ответа с диска.
</p> <blockquote class="note">
До версии 1.9.5 по умолчанию использовалось значение 1 32k.
</blockquote><p> 
</p><a name="port_in_redirect"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>port_in_redirect</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>port_in_redirect on;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает указывать порт в
<a href="#absolute_redirect">абсолютных</a>
перенаправлениях, выдаваемых nginx’ом.
</p><p>
Использование в перенаправлениях основного имени сервера управляется
директивой <a href="#server_name_in_redirect">server_name_in_redirect</a>.
</p><a name="postpone_output"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>postpone_output</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>postpone_output 1460;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Если это возможно, то отправка данных клиенту будет отложена пока nginx не
накопит по крайней мере указанное количество байт для отправки.
Значение 0 запрещает отложенную отправку данных.
</p><a name="read_ahead"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>read_ahead</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>read_ahead 0;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт ядру размер предчтения при работе с файлами.
</p><p>
На Linux используется системный вызов
<code>posix_fadvise(0, 0, 0, POSIX_FADV_SEQUENTIAL)</code>,
поэтому параметр <code><i>размер</i></code> там игнорируется.
</p><p>
На FreeBSD используется системный вызов
<code>fcntl(O_READAHEAD,
</code><code><i>размер</i></code><code>)</code>,
появившийся во FreeBSD 9.0-CURRENT.
Для FreeBSD 7 необходимо установить
<a href="http://sysoev.ru/freebsd/patch.readahead.txt">патч</a>.
</p><a name="recursive_error_pages"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>recursive_error_pages</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>recursive_error_pages off;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает делать несколько перенаправлений через директиву
<a href="#error_page">error_page</a>.
Число таких перенаправлений <a href="#internal">ограничено</a>.
</p><a name="request_pool_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>request_pool_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>request_pool_size 4k;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Позволяет производить точную настройку выделений памяти
под конкретные запросы.
Эта директива не оказывает существенного влияния на
производительность, и её не следует использовать.
</p><a name="reset_timedout_connection"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>reset_timedout_connection</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>reset_timedout_connection off;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает сброс соединений по таймауту,
а также при
<a href="ngx_http_rewrite_module.html#return">закрытии</a>
соединений с помощью нестандартного кода 444 (1.15.2).
Сброс делается следующим образом.
Перед закрытием сокета для него задаётся параметр
<code>SO_LINGER</code>
с таймаутом 0.
После этого при закрытии сокета клиенту отсылается TCP RST, а вся память,
связанная с этим сокетом, освобождается.
Это позволяет избежать длительного нахождения уже закрытого сокета в
состоянии FIN_WAIT1 с заполненными буферами.
</p><p>
Необходимо отметить, что keep-alive соединения по истечении таймаута
закрываются обычным образом.
</p><a name="resolver"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>resolver</strong> 
    <code><i>адрес</i></code> ...
    [<code>valid</code>=<code><i>время</i></code>]
    [<code>ipv4</code>=<code>on</code>|<code>off</code>]
    [<code>ipv6</code>=<code>on</code>|<code>off</code>]
    [<code>status_zone</code>=<code><i>зона</i></code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт серверы DNS, используемые для преобразования имён вышестоящих серверов
в адреса, например:
</p> <blockquote class="example"><pre>
resolver 127.0.0.1 [::1]:5353;
</pre></blockquote><p> 
Адрес может быть указан в виде доменного имени или IP-адреса,
и необязательного порта (1.3.1, 1.2.2).
Если порт не указан, используется порт 53.
Серверы DNS опрашиваются циклически.
</p> <blockquote class="note">
До версии 1.1.7 можно было задать лишь один DNS-сервер.
Задание DNS-серверов с помощью IPv6-адресов поддерживается
начиная с версий 1.3.1 и 1.2.2.
</blockquote><p> 
</p><a name="resolver_ipv6"></a><p>
По умолчанию nginx будет искать как IPv4-, так и IPv6-адреса
при преобразовании имён в адреса.
Если поиск IPv4- или IPv6-адресов нежелателен,
можно указать параметр <code>ipv4=off</code> (1.23.1) или
<code>ipv6=off</code>.
</p> <blockquote class="note">
Преобразование имён в IPv6-адреса поддерживается
начиная с версии 1.5.8.
</blockquote><p> 
</p><a name="resolver_valid"></a><p>
По умолчанию nginx кэширует ответы, используя значение TTL из ответа.
Необязательный параметр <code>valid</code> позволяет это
переопределить:
</p> <blockquote class="example"><pre>
resolver 127.0.0.1 [::1]:5353 valid=30s;
</pre></blockquote><p> 
</p> <blockquote class="note">
До версии 1.1.9 настройка времени кэширования была невозможна
и nginx всегда кэшировал ответы на срок в 5 минут.
</blockquote><p> 
</p> <blockquote class="note">
Для предотвращения DNS-спуфинга рекомендуется
использовать DNS-серверы в защищённой доверенной локальной сети.
</blockquote><p> 
</p><a name="resolver_status_zone"></a><p>
Необязательный параметр <code>status_zone</code> (1.17.1)
включает
<a href="ngx_http_api_module.html#resolvers_">сбор информации</a>
о запросах и ответах сервера DNS
в указанной <code><i>зоне</i></code>.
Параметр доступен как часть
<a href="http://nginx.com/products/">коммерческой подписки</a>.
</p><a name="resolver_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>resolver_timeout</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>resolver_timeout 30s;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт таймаут для преобразования имени в адрес, например:
</p> <blockquote class="example"><pre>
resolver_timeout 5s;
</pre></blockquote><p> 
</p><a name="root"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>root</strong> <code><i>путь</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>root html;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code>, <code>if в location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт корневой каталог для запросов.
Например, при такой конфигурации
</p> <blockquote class="example"><pre>
location /i/ {
    root /data/w3;
}
</pre></blockquote><p> 
в ответ на запрос “<code>/i/top.gif</code>” будет отдан файл
<code>/data/w3/i/top.gif</code>.
</p><p>
В значении параметра <code><i>путь</i></code> можно использовать переменные,
кроме <code>$document_root</code> и <code>$realpath_root</code>.
</p><p>
Путь к файлу формируется путём простого добавления URI к значению директивы
<code>root</code>.
Если же URI необходимо поменять, следует воспользоваться директивой
<a href="#alias">alias</a>.
</p><a name="satisfy"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>satisfy</strong> <code>all</code> | <code>any</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>satisfy all;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает доступ, если все (<code>all</code>)
или хотя бы один (<code>any</code>) из модулей
<a href="ngx_http_access_module.html">ngx_http_access_module</a>,
<a href="ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a>,
<a href="ngx_http_auth_request_module.html">ngx_http_auth_request_module</a>
или
<a href="ngx_http_auth_jwt_module.html">ngx_http_auth_jwt_module</a>
разрешают доступ.
</p><p>
Пример:
</p> <blockquote class="example"><pre>
location / {
    satisfy any;

    allow 192.168.1.0/32;
    deny  all;

    auth_basic           "closed site";
    auth_basic_user_file conf/htpasswd;
}
</pre></blockquote><p> 
</p><a name="send_lowat"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>send_lowat</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>send_lowat 0;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
При установке этой директивы в ненулевое значение nginx будет пытаться
минимизировать число операций отправки на клиентских сокетах либо при
помощи флага <code>NOTE_LOWAT</code> метода
<a href="../events.html#kqueue">kqueue</a>,
либо при помощи параметра сокета <code>SO_SNDLOWAT</code>.
В обоих случаях будет использован указанный <code><i>размер</i></code>.
</p><p>
Эта директива игнорируется на Linux, Solaris и Windows.
</p><a name="send_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>send_timeout</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>send_timeout 60s;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт таймаут при передаче ответа клиенту.
Таймаут устанавливается не на всю передачу ответа,
а только между двумя операциями записями.
Если по истечении этого времени клиент ничего не примет,
соединение будет закрыто.
</p><a name="sendfile"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>sendfile</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>sendfile off;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code>, <code>if в location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает использовать
<code>sendfile()</code>.
</p><p>
Начиная с nginx 0.8.12 и FreeBSD 5.2.1,
можно использовать <a href="#aio">aio</a> для подгрузки данных
для <code>sendfile()</code>:
</p> <blockquote class="example"><pre>
location /video/ {
    sendfile       on;
    tcp_nopush     on;
    aio            on;
}
</pre></blockquote><p> 
В такой конфигурации функция <code>sendfile()</code> вызывается с флагом
<code>SF_NODISKIO</code>, в результате чего она не блокируется на диске, а
сообщает об отсутствии данных в памяти.
После этого nginx инициирует асинхронную подгрузку данных, читая один байт.
При этом ядро FreeBSD подгружает в память первые 128K байт файла, однако
при последующих чтениях файл подгружается частями только по 16K.
Изменить это можно с помощью директивы
<a href="#read_ahead">read_ahead</a>.
</p> <blockquote class="note">
До версии 1.7.11 подгрузка данных включалась с помощью
<code>aio sendfile;</code>.
</blockquote><p> 
</p><a name="sendfile_max_chunk"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>sendfile_max_chunk</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>sendfile_max_chunk 2m;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Ограничивает объём данных,
который может передан за один вызов <code>sendfile()</code>.
Без этого ограничения одно быстрое соединение может целиком
захватить рабочий процесс.
</p> <blockquote class="note">
До версии 1.21.4 по умолчанию ограничения не было.
</blockquote><p> 
</p><a name="server"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>server</strong> { ... }</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт конфигурацию для виртуального сервера.
Чёткого разделения виртуальных серверов на IP-based (на основании IP-адреса)
и name-based (на основании поля “Host” заголовка запроса) нет.
Вместо этого директивами <a href="#listen">listen</a> описываются все
адреса и порты, на которых нужно принимать соединения для этого сервера,
а в директиве <a href="#server_name">server_name</a> указываются все имена серверов.
Примеры конфигураций описаны в документе
“<a href="request_processing.html">Как nginx обрабатывает запросы</a>”.
</p><a name="server_name"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>server_name</strong> <code><i>имя</i></code> ...;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>server_name "";</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт имена виртуального сервера, например:
</p> <blockquote class="example"><pre>
server {
    server_name example.com www.example.com;
}
</pre></blockquote><p> 
</p><p>
Первое имя становится основным именем сервера.
</p><p>
В именах серверов можно использовать звёздочку (“<code>*</code>”)
для замены первой или последней части имени:
</p> <blockquote class="example"><pre>
server {
    server_name example.com *.example.com www.example.*;
}
</pre></blockquote><p> 
Такие имена называются именами с маской.
</p><p>
Два первых вышеприведённых имени можно объединить в одно:
</p> <blockquote class="example"><pre>
server {
    server_name .example.com;
}
</pre></blockquote><p> 
</p><p>
В качестве имени сервера можно также использовать регулярное выражение,
указав перед ним тильду (“<code>~</code>”):
</p> <blockquote class="example"><pre>
server {
    server_name www.example.com ~^www\d+\.example\.com$;
}
</pre></blockquote><p> 
</p><p>
Регулярное выражение может содержать выделения (0.7.40),
которые могут затем использоваться в других директивах:
</p> <blockquote class="example"><pre>
server {
    server_name ~^(www\.)?(.+)$;

    location / {
        root /sites/$2;
    }
}

server {
    server_name _;

    location / {
        root /sites/default;
    }
}
</pre></blockquote><p> 
</p><p>
Именованные выделения в регулярном выражении создают переменные (0.8.25),
которые могут затем использоваться в других директивах:
</p> <blockquote class="example"><pre>
server {
    server_name ~^(www\.)?(?&lt;domain&gt;.+)$;

    location / {
        root /sites/$domain;
    }
}

server {
    server_name _;

    location / {
        root /sites/default;
    }
}
</pre></blockquote><p> 
</p><p>
Если параметр директивы установлен в “<code>$hostname</code>” (0.9.4), то
подставляется имя хоста (hostname) машины.
</p><p>
Возможно также указать пустое имя сервера (0.7.11):
</p> <blockquote class="example"><pre>
server {
    server_name www.example.com "";
}
</pre></blockquote><p> 
Это позволяет обрабатывать запросы без поля “Host” заголовка
запроса в этом сервере, а не в сервере по умолчанию для данной пары адрес:порт.
Это настройка по умолчанию.
</p> <blockquote class="note">
До 0.8.48 по умолчанию использовалось имя хоста (hostname) машины.
</blockquote><p> 
</p><p>
При поиске виртуального сервера по имени,
если имени соответствует несколько из указанных вариантов,
например, одновременно подходят и имя с маской, и регулярное выражение,
будет выбран первый подходящий вариант в следующем порядке приоритета:
</p> <ol class="compact">

<li>
точное имя
</li>

<li>
самое длинное имя с маской в начале,
например “<code>*.example.com</code>”
</li>

<li>
самое длинное имя с маской в конце,
например “<code>mail.*</code>”
</li>

<li>
первое подходящее регулярное выражение
(в порядке следования в конфигурационном файле)
</li>

</ol><p> 
</p><p>
Подробнее имена серверов обсуждаются в отдельном
<a href="server_names.html">документе</a>.
</p><a name="server_name_in_redirect"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>server_name_in_redirect</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>server_name_in_redirect off;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает использовать в
<a href="#absolute_redirect">абсолютных</a> перенаправлениях,
выдаваемых nginx’ом, основное имя сервера, задаваемое директивой
<a href="#server_name">server_name</a>.
Если использование основного имени сервера запрещено, то используется имя,
указанное в поле “Host” заголовка запроса.
Если же этого поля нет, то используется IP-адрес сервера.
</p><p>
Использование в перенаправлениях порта управляется
директивой <a href="#port_in_redirect">port_in_redirect</a>.
</p><a name="server_names_hash_bucket_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>server_names_hash_bucket_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>server_names_hash_bucket_size 32|64|128;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт размер корзины в хэш-таблицах имён серверов.
Значение по умолчанию зависит от размера строки кэша процессора.
Подробнее настройка хэш-таблиц обсуждается в отдельном
<a href="../hash.html">документе</a>.
</p><a name="server_names_hash_max_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>server_names_hash_max_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>server_names_hash_max_size 512;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт максимальный <code><i>размер</i></code> хэш-таблиц имён серверов.
Подробнее настройка хэш-таблиц обсуждается в отдельном
<a href="../hash.html">документе</a>.
</p><a name="server_tokens"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>server_tokens</strong> 
    <code>on</code> |
    <code>off</code> |
    <code>build</code> |
    <code><i>строка</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>server_tokens on;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает выдавать версию nginx’а на страницах ошибок и
в поле “Server” заголовка ответа.
</p><a name="server_tokens_build"></a><p>
Если указан параметр <code>build</code> (1.11.10),
то наряду с версией nginx’а будет также выдаваться
<a href="../configure.html#build">имя сборки</a>.
</p><p>
Дополнительно, как часть
<a href="http://nginx.com/products/">коммерческой подписки</a>,
начиная с версии 1.9.13
подписи на страницах ошибок и
значение поля “Server” заголовка ответа
можно задать явно с помощью строки с переменными.
Пустая строка запрещает выдачу поля “Server”.
</p><a name="subrequest_output_buffer_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>subrequest_output_buffer_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>subrequest_output_buffer_size 4k|8k;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.13.10.
            </p></div><p>
Задаёт <code><i>размер</i></code> буфера, используемого для
хранения тела ответа подзапроса.
По умолчанию размер одного буфера равен размеру страницы памяти.
В зависимости от платформы это или 4K, или 8K,
однако его можно сделать меньше.
</p><p>
Директива применима только для подзапросов,
тело ответа которых сохраняется в памяти.
Например, подобные подзапросы создаются при помощи
<a href="ngx_http_ssi_module.html#ssi_include_set">SSI</a>.
</p><a name="tcp_nodelay"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>tcp_nodelay</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>tcp_nodelay on;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает использование параметра <code>TCP_NODELAY</code>.
Параметр включается при переходе соединения в состояние keep-alive.
Также, он включается на SSL-соединениях,
при небуферизованном проксировании
и при проксировании <a href="websocket.html">WebSocket</a>.
</p><a name="tcp_nopush"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>tcp_nopush</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>tcp_nopush off;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает использование параметра сокета
<code>TCP_NOPUSH</code> во FreeBSD или
<code>TCP_CORK</code> в Linux.
Параметр включаются только при использовании <a href="#sendfile">sendfile</a>.
Включение параметра  позволяет
</p> <ul class="compact">

<li>
передавать заголовок ответа и начало файла в одном пакете
в Linux и во FreeBSD 4.*;
</li>

<li>
передавать файл полными пакетами.
</li>

</ul><p> 
</p><a name="try_files"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>try_files</strong> <code><i>файл</i></code> ... <code><i>uri</i></code>;</code><br><code><strong>try_files</strong> <code><i>файл</i></code> ... =<code><i>код</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            
            —
        
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Проверяет существование файлов в заданном порядке и использует
для обработки запроса первый найденный файл, причём обработка
делается в контексте этого же location’а.
Путь к файлу строится из параметра <code><i>файл</i></code>
в соответствии с директивами
<a href="#root">root</a> и <a href="#alias">alias</a>.
С помощью слэша в конце имени можно проверить существование каталога,
например, “<code>$uri/</code>”.
В случае, если ни один файл не найден, то делается внутреннее
перенаправление на <code><i>uri</i></code>, заданный последним параметром.
Например:
</p> <blockquote class="example"><pre>
location /images/ {
    try_files $uri /images/default.gif;
}

location = /images/default.gif {
    expires 30s;
}
</pre></blockquote><p> 
Последний параметр может также указывать на именованный location,
как в примерах ниже.
С версии 0.7.51 последний параметр может также быть <code><i>кодом</i></code>:
</p> <blockquote class="example"><pre>
location / {
    try_files $uri $uri/index.html $uri.html =404;
}
</pre></blockquote><p> 
</p><p>
Пример использования при проксировании Mongrel:
</p> <blockquote class="example"><pre>
location / {
    try_files /system/maintenance.html
              $uri $uri/index.html $uri.html
              @mongrel;
}

location @mongrel {
    proxy_pass http://mongrel;
}
</pre></blockquote><p> 
</p><p>
Пример использования вместе с Drupal/FastCGI:
</p> <blockquote class="example"><pre>
location / {
    try_files $uri $uri/ @drupal;
}

location ~ \.php$ {
    try_files $uri @drupal;

    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;
    fastcgi_param SCRIPT_NAME     $fastcgi_script_name;
    fastcgi_param QUERY_STRING    $args;

    ... прочие fastcgi_param
}

location @drupal {
    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to/index.php;
    fastcgi_param SCRIPT_NAME     /index.php;
    fastcgi_param QUERY_STRING    q=$uri&amp;$args;

    ... прочие fastcgi_param
}
</pre></blockquote><p> 
В следующем примере директива <code>try_files</code>
</p> <blockquote class="example"><pre>
location / {
    try_files $uri $uri/ @drupal;
}
</pre></blockquote><p> 
аналогична директивам
</p> <blockquote class="example"><pre>
location / {
    error_page 404 = @drupal;
    log_not_found off;
}
</pre></blockquote><p> 
А здесь
</p> <blockquote class="example"><pre>
location ~ \.php$ {
    try_files $uri @drupal;

    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;

    ...
}
</pre></blockquote><p> 
<code>try_files</code> проверяет существование PHP-файла,
прежде чем передать запрос FastCGI-серверу.
</p><p>
Пример использования вместе с Wordpress и Joomla:
</p> <blockquote class="example"><pre>
location / {
    try_files $uri $uri/ @wordpress;
}

location ~ \.php$ {
    try_files $uri @wordpress;

    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;
    ... прочие fastcgi_param
}

location @wordpress {
    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to/index.php;
    ... прочие fastcgi_param
}
</pre></blockquote><p> 
</p><a name="types"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>types</strong> { ... }</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>types {
    text/html  html;
    image/gif  gif;
    image/jpeg jpg;
}</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт соответствие расширений имён файлов и MIME-типов ответов.
Расширения нечувствительны к регистру символов.
Одному MIME-типу может соответствовать несколько расширений, например:
</p> <blockquote class="example"><pre>
types {
    application/octet-stream bin exe dll;
    application/octet-stream deb;
    application/octet-stream dmg;
}
</pre></blockquote><p> 
</p><p>
Достаточно полная таблица соответствий входит в дистрибутив nginx
и находится в файле <code>conf/mime.types</code>.
</p><p>
Для того чтобы для определённого location’а для всех ответов
выдавался MIME-тип “<code>application/octet-stream</code>”,
можно использовать следующее:
</p> <blockquote class="example"><pre>
location /download/ {
    types        { }
    default_type application/octet-stream;
}
</pre></blockquote><p> 
</p><a name="types_hash_bucket_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>types_hash_bucket_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>types_hash_bucket_size 64;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт размер корзины в хэш-таблицах типов.
Подробнее настройка хэш-таблиц обсуждается в отдельном
<a href="../hash.html">документе</a>.
</p> <blockquote class="note">
До версии 1.5.13
значение по умолчанию зависело от размера строки кэша процессора.
</blockquote><p> 
</p><a name="types_hash_max_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>types_hash_max_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>types_hash_max_size 1024;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт максимальный <code><i>размер</i></code> хэш-таблиц типов.
Подробнее настройка хэш-таблиц обсуждается в отдельном
<a href="../hash.html">документе</a>.
</p><a name="underscores_in_headers"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>underscores_in_headers</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>underscores_in_headers off;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code>, <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает использование символов подчёркивания в
полях заголовка запроса клиента.
Если использование символов подчёркивания запрещено, поля заголовка запроса, в
именах которых есть подчёркивания,
помечаются как недопустимые и подпадают под действие директивы
<a href="#ignore_invalid_headers">ignore_invalid_headers</a>.
</p><p>
Если директива указана на уровне <a href="#server">server</a>,
то может использоваться значение из сервера по умолчанию.
Подробнее см. в разделе
“<a href="server_names.html#virtual_server_selection">Выбор
виртуального сервера</a>”.
</p><a name="variables_hash_bucket_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>variables_hash_bucket_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>variables_hash_bucket_size 64;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт размер корзины в хэш-таблице переменных.
Подробнее настройка хэш-таблиц обсуждается в отдельном
<a href="../hash.html">документе</a>.
</p><a name="variables_hash_max_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <th>
            Синтаксис:
                </th>
                <td>
            <code><strong>variables_hash_max_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <th>
            Умолчание:
                </th>
                <td>
            <pre>variables_hash_max_size 1024;</pre>
                </td>
                </tr>
            
                <tr>
                <th>
            Контекст:
                </th>
                <td>
            <code>http</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт максимальный <code><i>размер</i></code> хэш-таблицы переменных.
Подробнее настройка хэш-таблиц обсуждается в отдельном
<a href="../hash.html">документе</a>.
</p> <blockquote class="note">
До версии 1.5.13 по умолчанию использовалось значение 512.
</blockquote><p> 
</p>


<a name="variables"></a><center><h4>Встроенные переменные</h4></center><p>
Модуль <code>ngx_http_core_module</code> поддерживает встроенные
переменные, имена которых совпадают с именами переменных веб-сервера Apache.
Прежде всего, это переменные, представляющие из себя поля заголовка
запроса клиента, такие как <code>$http_user_agent</code>, <code>$http_cookie</code>
и тому подобное.
Кроме того, есть и другие переменные:
</p> <dl class="compact">

<dt id="var_arg_"><code>$arg_</code><code><i>имя</i></code></dt>
<dd>
аргумент <code><i>имя</i></code> в строке запроса
</dd>

<dt id="var_args"><code>$args</code></dt>
<dd>
аргументы в строке запроса
</dd>

<dt id="var_binary_remote_addr"><code>$binary_remote_addr</code></dt>
<dd>
адрес клиента в бинарном виде, длина значения всегда 4 байта
для IPv4-адресов или 16 байт для IPv6-адресов
</dd>

<dt id="var_body_bytes_sent"><code>$body_bytes_sent</code></dt>
<dd>
число байт, переданное клиенту, без учёта заголовка ответа;
переменная совместима с параметром “<code>%B</code>” модуля Apache
<code>mod_log_config</code>
</dd>

<dt id="var_bytes_sent"><code>$bytes_sent</code></dt>
<dd>
число байт, переданных клиенту (1.3.8, 1.2.5)
</dd>

<dt id="var_connection"><code>$connection</code></dt>
<dd>
порядковый номер соединения (1.3.8, 1.2.5)
</dd>

<dt id="var_connection_requests"><code>$connection_requests</code></dt>
<dd>
текущее число запросов в соединении (1.3.8, 1.2.5)
</dd>

<dt id="var_connection_time"><code>$connection_time</code></dt>
<dd>
время соединения в секундах с точностью до миллисекунд (1.19.10)
</dd>

<dt id="var_content_length"><code>$content_length</code></dt>
<dd>
поле “Content-Length” заголовка запроса
</dd>

<dt id="var_content_type"><code>$content_type</code></dt>
<dd>
поле “Content-Type” заголовка запроса
</dd>

<dt id="var_cookie_"><code>$cookie_</code><code><i>имя</i></code></dt>
<dd>
cookie <code><i>имя</i></code>
</dd>

<dt id="var_document_root"><code>$document_root</code></dt>
<dd>
значение директивы <a href="#root">root</a> или <a href="#alias">alias</a>
для текущего запроса
</dd>

<dt id="var_document_uri"><code>$document_uri</code></dt>
<dd>
то же, что и <code>$uri</code>
</dd>

<dt id="var_host"><code>$host</code></dt>
<dd>
в порядке приоритета:
имя хоста из строки запроса, или
имя хоста из поля “Host” заголовка запроса, или
имя сервера, соответствующего запросу
</dd>

<dt id="var_hostname"><code>$hostname</code></dt>
<dd>
имя хоста
</dd>

<dt id="var_http_"><code>$http_</code><code><i>имя</i></code></dt>
<dd>
произвольное поле заголовка запроса;
последняя часть имени переменной соответствует имени поля, приведённому
к нижнему регистру, с заменой символов тире на символы подчёркивания
</dd>

<dt id="var_https"><code>$https</code></dt>
<dd>
“<code>on</code>”
если соединение работает в режиме SSL,
либо пустая строка
</dd>

<dt id="var_is_args"><code>$is_args</code></dt>
<dd>
“<code>?</code>”, если в строке запроса есть аргументы,
и пустая строка, если их нет
</dd>

<dt id="var_limit_rate"><code>$limit_rate</code></dt>
<dd>
установка этой переменной позволяет ограничивать скорость
передачи ответа, см. <a href="#limit_rate">limit_rate</a>
</dd>

<dt id="var_msec"><code>$msec</code></dt>
<dd>
текущее время в секундах с точностью до миллисекунд (1.3.9, 1.2.6)
</dd>

<dt id="var_nginx_version"><code>$nginx_version</code></dt>
<dd>
версия nginx
</dd>

<dt id="var_pid"><code>$pid</code></dt>
<dd>
номер (PID) рабочего процесса
</dd>

<dt id="var_pipe"><code>$pipe</code></dt>
<dd>
“<code>p</code>” если запрос был pipelined, иначе “<code>.</code>”
(1.3.12, 1.2.7)
</dd>

<dt id="var_proxy_protocol_addr"><code>$proxy_protocol_addr</code></dt>
<dd>
адрес клиента, полученный из заголовка протокола PROXY (1.5.12)
<p>
Протокол PROXY должен быть предварительно включён при помощи установки
параметра <code>proxy_protocol</code> в директиве <a href="#listen">listen</a>.
</p>
</dd>

<dt id="var_proxy_protocol_port"><code>$proxy_protocol_port</code></dt>
<dd>
порт клиента, полученный из заголовка протокола PROXY (1.11.0)
<p>
Протокол PROXY должен быть предварительно включён при помощи установки
параметра <code>proxy_protocol</code> в директиве <a href="#listen">listen</a>.
</p>
</dd>

<dt id="var_proxy_protocol_server_addr"><code>$proxy_protocol_server_addr</code></dt>
<dd>
адрес сервера, полученный из заголовка протокола PROXY (1.17.6)
<p>
Протокол PROXY должен быть предварительно включён при помощи установки
параметра <code>proxy_protocol</code> в директиве <a href="#listen">listen</a>.
</p>
</dd>

<dt id="var_proxy_protocol_server_port"><code>$proxy_protocol_server_port</code></dt>
<dd>
порт сервера, полученный из заголовка протокола PROXY (1.17.6)
<p>
Протокол PROXY должен быть предварительно включён при помощи установки
параметра <code>proxy_protocol</code> в директиве <a href="#listen">listen</a>.
</p>
</dd>

<dt id="var_proxy_protocol_tlv_"><code>$proxy_protocol_tlv_</code><code><i>имя</i></code></dt>
<dd>
TLV, полученный из заголовка протокола PROXY (1.23.2).
<code>Имя</code> может быть именем типа TLV или его числовым значением.
В последнем случае значение задаётся в шестнадцатеричном виде
и должно начинаться с <code>0x</code>:

<blockquote class="example"><pre>
$proxy_protocol_tlv_alpn
$proxy_protocol_tlv_0x01
</pre></blockquote>
SSL TLV могут также быть доступны как по имени типа TLV,
так и по его числовому значению,
оба должны начинаться с <code>ssl_</code>:
<blockquote class="example"><pre>
$proxy_protocol_tlv_ssl_version
$proxy_protocol_tlv_ssl_0x21
</pre></blockquote>

<p>
Поддерживаются следующие имена типов TLV:
</p> <ul class="compact">

<li>
<code>alpn</code> (<code>0x01</code>) - 
протокол более высокого уровня, используемый поверх соединения
</li>

<li>
<code>authority</code> (<code>0x02</code>) - 
значение имени хоста, передаваемое клиентом
</li>

<li>
<code>unique_id</code> (<code>0x05</code>) - 
уникальный идентификатор соединения
</li>

<li>
<code>netns</code> (<code>0x30</code>) - 
имя пространства имён
</li>

<li>
<code>ssl</code> (<code>0x20</code>) - 
структура SSL TLV в бинарном виде
</li>

</ul><p> 
</p>

<p>
Поддерживаются следующие имена типов SSL TLV:
</p> <ul class="compact">

<li>
<code>ssl_version</code> (<code>0x21</code>) - 
версия SSL, используемая в клиентском соединении
</li>

<li>
<code>ssl_cn</code> (<code>0x22</code>) - 
Common Name сертификата
</li>

<li>
<code>ssl_cipher</code> (<code>0x23</code>) - 
имя используемого шифра
</li>

<li>
<code>ssl_sig_alg</code> (<code>0x24</code>) - 
алгоритм, используемый для подписи сертификата
</li>

<li>
<code>ssl_key_alg</code> (<code>0x25</code>) - 
алгоритм публичного ключа
</li>

</ul><p> 
</p>

<p>
Также поддерживается следующее специальное имя типа SSL TLV:
</p> <ul class="compact">

<li>
<code>ssl_verify</code> - 
результат проверки клиентского сертификата:
<code>0</code>, если клиент предоставил сертификат
и он был успешно верифицирован,
либо ненулевое значение
</li>

</ul><p> 
</p>

<p>
Протокол PROXY должен быть предварительно включён при помощи установки
параметра <code>proxy_protocol</code> в директиве <a href="#listen">listen</a>.
</p>
</dd>

<dt id="var_query_string"><code>$query_string</code></dt>
<dd>
то же, что и <code>$args</code>
</dd>

<dt id="var_realpath_root"><code>$realpath_root</code></dt>
<dd>
абсолютный путь, соответствующий
значению директивы <a href="#root">root</a> или <a href="#alias">alias</a>
для текущего запроса,
в котором все символические ссылки преобразованы в реальные пути
</dd>

<dt id="var_remote_addr"><code>$remote_addr</code></dt>
<dd>
адрес клиента
</dd>

<dt id="var_remote_port"><code>$remote_port</code></dt>
<dd>
порт клиента
</dd>

<dt id="var_remote_user"><code>$remote_user</code></dt>
<dd>
имя пользователя, использованное в Basic аутентификации
</dd>

<dt id="var_request"><code>$request</code></dt>
<dd>
первоначальная строка запроса целиком
</dd>

<dt id="var_request_body"><code>$request_body</code></dt>
<dd>
тело запроса
<p>
Значение переменной появляется в location’ах, обрабатываемых
директивами
<a href="ngx_http_proxy_module.html#proxy_pass">proxy_pass</a>,
<a href="ngx_http_fastcgi_module.html#fastcgi_pass">fastcgi_pass</a>,
<a href="ngx_http_uwsgi_module.html#uwsgi_pass">uwsgi_pass</a>
и
<a href="ngx_http_scgi_module.html#scgi_pass">scgi_pass</a>,
когда тело было прочитано в
<a href="#client_body_buffer_size">буфер в памяти</a>.
</p>
</dd>

<dt id="var_request_body_file"><code>$request_body_file</code></dt>
<dd>
имя временного файла, в котором хранится тело запроса
<p>
По завершении обработки файл необходимо удалить.
Для того чтобы тело запроса всегда записывалось в файл,
следует включить <a href="#client_body_in_file_only">client_body_in_file_only</a>.
При передаче имени временного файла в проксированном запросе
или в запросе к FastCGI/uwsgi/SCGI-серверу следует запретить передачу самого
тела директивами
<a href="ngx_http_proxy_module.html#proxy_pass_request_body">
proxy_pass_request_body off</a>,
<a href="ngx_http_fastcgi_module.html#fastcgi_pass_request_body">
fastcgi_pass_request_body off</a>,
<a href="ngx_http_uwsgi_module.html#uwsgi_pass_request_body">
uwsgi_pass_request_body off</a>
или
<a href="ngx_http_scgi_module.html#scgi_pass_request_body">
scgi_pass_request_body off</a>
соответственно.
</p>
</dd>

<dt id="var_request_completion"><code>$request_completion</code></dt>
<dd>
“<code>OK</code>” если запрос завершился,
либо пустая строка
</dd>

<dt id="var_request_filename"><code>$request_filename</code></dt>
<dd>
путь к файлу для текущего запроса, формируемый из директив
<a href="#root">root</a> или <a href="#alias">alias</a> и URI запроса
</dd>

<dt id="var_request_id"><code>$request_id</code></dt>
<dd>
уникальный идентификатор запроса,
сформированный из 16 случайных байт, в шестнадцатеричном виде (1.11.0)
</dd>

<dt id="var_request_length"><code>$request_length</code></dt>
<dd>
длина запроса (включая строку запроса, заголовок и тело запроса)
(1.3.12, 1.2.7)
</dd>

<dt id="var_request_method"><code>$request_method</code></dt>
<dd>
метод запроса, обычно
“<code>GET</code>” или “<code>POST</code>”
</dd>

<dt id="var_request_time"><code>$request_time</code></dt>
<dd>
время обработки запроса в секундах с точностью до миллисекунд
(1.3.9, 1.2.6);
время, прошедшее с момента чтения первых байт от клиента
</dd>

<dt id="var_request_uri"><code>$request_uri</code></dt>
<dd>
первоначальный URI запроса целиком (с аргументами)
</dd>

<dt id="var_scheme"><code>$scheme</code></dt>
<dd>
схема запроса, “<code>http</code>” или “<code>https</code>”
</dd>

<dt id="var_sent_http_"><code>$sent_http_</code><code><i>имя</i></code></dt>
<dd>
произвольное поле заголовка ответа;
последняя часть имени переменной соответствует имени поля, приведённому
к нижнему регистру, с заменой символов тире на символы подчёркивания
</dd>

<dt id="var_sent_trailer_"><code>$sent_trailer_</code><code><i>имя</i></code></dt>
<dd>
произвольное поле, отправленное в конце ответа (1.13.2);
последняя часть имени переменной соответствует имени поля, приведённому
к нижнему регистру, с заменой символов тире на символы подчёркивания
</dd>

<dt id="var_server_addr"><code>$server_addr</code></dt>
<dd>
адрес сервера, принявшего запрос
<p>
Получение значения этой переменной обычно требует одного системного вызова.
Чтобы избежать системного вызова, в директивах <a href="#listen">listen</a>
следует указывать адреса и использовать параметр <code>bind</code>.
</p>
</dd>

<dt id="var_server_name"><code>$server_name</code></dt>
<dd>
имя сервера, принявшего запрос
</dd>

<dt id="var_server_port"><code>$server_port</code></dt>
<dd>
порт сервера, принявшего запрос
</dd>

<dt id="var_server_protocol"><code>$server_protocol</code></dt>
<dd>
протокол запроса, обычно
“<code>HTTP/1.0</code>”,
“<code>HTTP/1.1</code>”,
“<a href="ngx_http_v2_module.html">HTTP/2.0</a>”
или
“<a href="ngx_http_v3_module.html">HTTP/3.0</a>”
</dd>

<dt id="var_status"><code>$status</code></dt>
<dd>
статус ответа (1.3.2, 1.2.2)
</dd>

<dt id="var_time_iso8601"><code>$time_iso8601</code></dt>
<dd>
локальное время в формате по стандарту ISO 8601 (1.3.12, 1.2.7)
</dd>

<dt id="var_time_local"><code>$time_local</code></dt>
<dd>
локальное время в Common Log Format (1.3.12, 1.2.7)
</dd>

<dt id="var_tcpinfo_">
<code>$tcpinfo_rtt</code>,
<code>$tcpinfo_rttvar</code>,
<code>$tcpinfo_snd_cwnd</code>,
<code>$tcpinfo_rcv_space</code>
</dt>
<dd>
информация о клиентском TCP-соединении; доступна на системах,
поддерживающих параметр сокета <code>TCP_INFO</code>
</dd>

<dt id="var_uri"><code>$uri</code></dt>
<dd>
текущий URI запроса в <a href="#location">нормализованном</a> виде
<p>
Значение <code>$uri</code> может изменяться в процессе обработки запроса,
например, при внутренних перенаправлениях
или при использовании индексных файлов.
</p>
</dd>

</dl><p> 
</p>

</div></div></body></html>
